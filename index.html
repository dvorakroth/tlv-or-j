<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
  <script src="/assets/leaflet-heat.js"></script>
  <style>
    @font-face {
        font-family: 'Heebo';
        src: url(/assets/Heebo-Regular.ttf) format('truetype');
    }
    body, .btn-pretty {
        font-family: 'Heebo', sans-serif;
    }
    #map {position: absolute; top: 0; right: 0; bottom: 0; left: 0;}
    .hidden {display: none !important;}
    .no-bg-no-border {background: none !important; border: none !important; /* don't ask */}
    #main-ui {
        display: block;
        z-index: 999;
        position: absolute;
        top: 25px;
        right: 25px;

        background-color: #fff;
        border: 1px solid #7f7f7f;
        padding: 40px 20px;

        text-align: center;

        transition: width 0.5s, height 0.5s;
    }
    
    #main-ui h1 {
        margin: 0 0 20px 0;
        font-size: 180%;
    }

    p {
        font-size: 120%;
    }

    .btn-pretty, .dramatic-or {
        font-size: 150%;
    }

    .btn-pretty {
        position: relative;
        display: inline-block;
        border: 2px solid black;
        border-radius: 10px;
        color: #fff;
        padding: 10px 30px;


        transition: all 0.25s;

        cursor:pointer;

        text-shadow: 0px 0px 4px black;
    }

    #btn-tlv {
        background: #63acbe;
        margin-left: 15px;
    }
    #btn-jaf {
        background-color:#a9299c;
        margin-right: 15px;
    }

    #btn-start {
        background-color: #800;
    }

    #btn-playagain {
        background-color: #0054ae;
    }

    #btn-tlv:hover, #btn-tlv:focus {
        background: #6fe0fc;
    }

    #btn-jaf:hover, #btn-jaf:focus {
        background-color: #bf53b4;
    }

    #btn-start:hover, #btn-start:focus {
        background-color: #d22;
    }

    #btn-playagain:hover, #btn-playagain:focus {
        background-color: #70ade3;
    }

    .btn-pretty:active {
        top: 1px;
        left: 1px;
    }

    #btn-light-switch {
        background-color: transparent;
        background-image: url('/assets/switch_light.svg');
        background-size: contain;
        background-repeat: no-repeat;

        border: none;
        
        position: absolute;
        left: 5px;
        top: 5px;

        width: 74px;
        height: 20px;

        cursor: pointer;
    }

    .fading-reward {
        position:absolute;

        animation-duration: 1s;
        animation-name: fade;
        animation-iteration-count: 1;
        animation-timing-function:  ease-out;

        opacity: 0%;
    }

    @keyframes fade {
        from {
            top: 0;
            opacity: 100%;
        }

        to {
            top: -70px;
            opacity: 0%;
            display:none;
        }
    }

    .pulsating {
        animation-duration: 1.5s;
        animation-name: pulse;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
        animation-direction: alternate;
    }

    @keyframes pulse {
        from {
            transform: scale(1.0);
        }

        to {
            transform: scale(0.6);
        }
    }

    #loading-page, #results-loading-page {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;

        min-width: 200px;
        min-height: 120px;

        font-size: 150%;
    }

    #loading-page > *,
    #results-loading-page > * {
        display: block;
    }

    .loading-indicator {
        width: 80px;
        height: 80px;
        border: 5px solid #333;
        border-radius: 100%;
        border-style: dashed;
        
        animation-duration: 5s;
        animation-name: rotate;
        animation-iteration-count: infinite;
        animation-timing-function:  linear;
    }

    @keyframes rotate {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }

    /* because this is plain css and not sass/less, i now have to duplicate the dark mode code */
    body.force-dark #main-ui {
        background-color: #000;
        color: #fff;
    }

    body.force-dark .btn-pretty {
        border-color: white;
    }

    body.force-dark #btn-light-switch {
        background-image: url('/assets/switch_dark.svg');
    }

    body.force-dark .loading-indicator {
        border-color: #fff;
    }

    @media (prefers-color-scheme: dark) {
        body:not(.force-light) #main-ui {
            background-color: #000;
            color: #fff;
        }

        body:not(.force-light) .btn-pretty {
            border-color: white;
        }

        body:not(.force-light) #btn-light-switch {
            background-image: url('/assets/switch_dark.svg');
        }

        body:not(.force-light) .loading-indicator {
            border-color: #fff;
        }
    }

    @media screen and (max-width: 760px) {
        #main-ui {
            display: flex;
            justify-content: center;
            align-items: center;

            top: unset;
            bottom: 0;
            left: 0;
            right: 0;

            border-left: none;
            border-right: none;
            border-bottom: none;

            box-sizing: border-box;

            min-height: 240px;
        }

        #map { 
            bottom: 240px;
            top: 0;
        }
    }
  </style>
  <title>תל אביב או יפו?</title>
</head>
<body dir="ltr" lang="he">
  <div id="map"></div>
  
  <div id="main-ui" dir="rtl">
    <button id="btn-light-switch" aria-label="שינוי בין מצב יום ומצב לילה"></button>

    <section id="loading-page">
        <div class="loading-indicator"></div>
        <span><br>בטעינה...</span>
    </section>

    <section id="intro-page" class="hidden">
        <h1>תל אביב או יפו?</h1>
        <p>הגבול בין תל אביב לבין יפו לגמרי מטושטש, אבל אם נעבוד ביחד, נוכל למצוא אותו שוב!</p>
        <button class="btn-pretty" id="btn-start">שנתחיל?</button>
    </section>

    <section id="question-page" class="hidden">
        <h1>באיזו עיר הנקודה המסומנת?</h1>
        <button class="btn-pretty" id="btn-tlv">תל אביב</button>
        <span class="dramatic-or">או</span>
        <button class="btn-pretty" id="btn-jaf">יפו</button>
    </section>

    <section id="results-loading-page" class="hidden">
        <div class="loading-indicator"></div>
        <span><br>התשובות בעיבוד סופר מתקדם...</span>
    </section>

    <section id="all-answers-page" class="hidden">
        <h1>התשובות הסופיות</h1>
        <p>הנה התשובות של כולן.ם! נכון שעכשיו המצב הרבה יותר ברור?</p>
        <button class="btn-pretty" id="btn-playagain">עוד הפעם!!</button>
    </section>
    
</div>
  
  <script>
    
    (function() {
        const TLV_COLOR = '#63acbe';
        const JAFFA_COLOR = '#a9299c';

        let GLOB_is_dark_mode = false;
        let GLOB_is_dark_forced = false; // are we forcing light/dark mode currently?

        if (window.matchMedia) {
            const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)');

            // when we just initialize, set the dark mode flag to match browser settings
            GLOB_is_dark_mode = !!matchDarkMode.matches;

            matchDarkMode.addEventListener('change', event => {
                // but when the setting is changed on the fly, only update the flag
                // if the user hasn't touched the light switch
                if (GLOB_is_dark_forced) {
                    return;
                }

                GLOB_is_dark_mode = !!event.matches;
                onDarkModeSettingChanged();
            })
        }

        function onDarkModeSettingChanged() {
            LAYER.setUrl(MAP_STYLES[GLOB_is_dark_mode|0]);
            if (STATE.question_idx <= 0) {
                refill_cache_for_mode(GLOB_is_dark_mode|0);
            }
        }

        document.getElementById('btn-light-switch').addEventListener('click', function(event) {
            // when the light switch is clicked:
            
            GLOB_is_dark_forced = true;
            GLOB_is_dark_mode = !GLOB_is_dark_mode;

            // force css to comply by adding class to the body:
            if (GLOB_is_dark_mode) {
                document.body.classList.add('force-dark');
                document.body.classList.remove('force-light');
            } else {
                document.body.classList.add('force-light');
                document.body.classList.remove('force-dark');
            }

            // and lastly, trigger the event that updates the map
            onDarkModeSettingChanged();
        });

        const STATE = window.STATE = {
            session_id: null,
            question_idx: -1,
            questions: null,
            markers: null,
            answers: null,
            answer_markers: null,

            is_animating: true,

            is_loading_results: false,
            renew_session_interval: null
        };

        const PRELOADED_IMAGE_XYZ  = window.PRELOADED_IMAGE_XYZ  = [];
        const PRELOADED_IMAGE_OBJS = window.PRELOADED_IMAGE_OBJS = [[], []];
        const TILE_SIZE = 512;
        const ZOOM_OFFSET = -1;

        const MIN_ZOOM_USUAL = 13;
        const MIN_ZOOM_ALL_ANSWERS = 12;
        const MAP_MAX_BOUNDS = L.latLngBounds(L.latLng(32.017357, 34.724041), L.latLng(32.159226, 34.867250));

        const MAP_STYLES = [
            'https://api.maptiler.com/maps/47c517fb-70bf-4903-89b4-2033ebbbedb1/{z}/{x}/{y}{r}.png?key=XQ643Hu2aW2ClNCu8gL4', // light
            'https://api.maptiler.com/maps/a3b10cf0-43d5-4a06-aefd-226a3a02a57c/{z}/{x}/{y}{r}.png?key=XQ643Hu2aW2ClNCu8gL4', // dark
        ];

        // initialize map and stuff
        const MAP = window.MAP = L.map('map', {
            zoomControl: false,
            bounceAtZoomLimits: false,

            minZoom: MIN_ZOOM_USUAL,
            maxZoom: 20,
            maxBounds: MAP_MAX_BOUNDS
        }).setView([32.058225, 34.770073], 14);

        const LAYER = L.tileLayer(
            MAP_STYLES[GLOB_is_dark_mode | 0],{
                tileSize: TILE_SIZE,
                zoomOffset: ZOOM_OFFSET,
                attribution: "\u003ca href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"\u003e\u0026copy; MapTiler\u003c/a\u003e \u003ca href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"\u003e\u0026copy; OpenStreetMap contributors\u003c/a\u003e",
                crossOrigin: true
        }).addTo(MAP);

        const HEAT_LAYER_TLV = L.heatLayer([], {
            minOpacity: 0.6,
            gradient: {0.0: 'rgba(0.0, 0.0, 0.0, 0.0)', 1.0: 'rgba(99, 172, 190, 0.6)'}
        }).addTo(MAP);
        

        const HEAT_LAYER_JAFFA = L.heatLayer([], {
            minOpacity: 0.6,
            gradient: {0.0: 'rgba(0.0, 0.0, 0.0, 0.0)', 1.0: 'rgba(191, 83, 180, 0.6)'}
        }).addTo(MAP);

        const QUESTION_VIEW_ZOOM = 16;

        const MARKER_Q = L.divIcon({
            html: '<img src="/assets/marker_q.svg" class="pulsating">',
            className: 'no-bg-no-border',

            iconSize: [60, 75],
            iconAnchor: [15, 37.5],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_TLV = L.icon({
            iconUrl: '/assets/marker_tlv.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_JAFFA = L.icon({
            iconUrl: '/assets/marker_jaffa.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const CAT_HEART = L.icon({
            iconUrl: '/assets/twemoji_catheart.svg',
            
            iconSize: [36, 36],
            iconAnchor: [18, 18],
            popupAnchor: [0, 0] // ?
        });

        function playAgain() {
            // reset the state and stuff
            STATE.session_id = null;
            STATE.questions = null;
            STATE.question_idx = -1;
            STATE.answers = null;
            clear_map_images_cache();
            clear_answer_markers();

            clear_renew_session_interval();

            document.getElementById('all-answers-page').classList.add('hidden');
            document.getElementById('loading-page').classList.remove('hidden');
            resize_map();

            loadQuestionsFromServer();
        }

        function clear_renew_session_interval() {
            if (STATE.renew_session_interval !== null) {
                clearInterval(STATE.renew_session_interval);
                STATE.renew_session_interval = null;
            }
        }

        function clear_answer_markers() {
            // if (!STATE.answer_markers) {
            //     return;
            // }

            // for (let i = 0; i < STATE.answer_markers.length; i++) {
            //     STATE.answer_markers[i].remove();
            // }

            for (let i = 0; i < STATE.markers.length; i++) {
                STATE.markers[i].remove();
            }

            STATE.markers = null;

            STATE.answer_markers = null;
            HEAT_LAYER_TLV.setLatLngs([]);
            HEAT_LAYER_JAFFA.setLatLngs([]);
        }

        function loadQuestionsFromServer() {
            fetch('/generate_session').then(function(response) {
                return response.json();
            }).then(function(o) {
                STATE.session_id = o.session_id;
                STATE.questions = o.points.map(([x, y]) => [y, x]);
                STATE.question_idx = -1; 
                STATE.answers = STATE.questions.map(() => null);
                STATE.markers = STATE.questions.map(() => null);

                const num_qs = STATE.questions.length;
                let preload_counter = 0;

                const start_ms = Date.now();

                for (const q of STATE.questions) {
                    preload_tile_neighborhood(
                        q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET, GLOB_is_dark_mode|0,
                        function() { // hello callback hell my old friend
                            preload_counter += 1; // haha gotta count till the end!!!!
                            if (preload_counter === num_qs && Date.now() - start_ms <= 1000) {
                                // load the outer zoom levels only if the inner zoom levels took less than 1s total
                                console.log('loading outer zoom levels');
                                for (const qq of STATE.questions) {
                                    preload_tile_neighborhood(q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET - 1, GLOB_is_dark_mode|0);
                                }
                            }
                        }
                    );
                    // preload_tile_neighborhood(q[0], q[1], QUESTION_VIEW_ZOOM - 2, GLOB_is_dark_mode|0);
                }

                clear_renew_session_interval();

                STATE.renew_session_interval = setInterval(
                    function() {
                        console.log("renewing session");
                        if (STATE.session_id && STATE.question_idx < (STATE.questions || []).length) {
                            fetch('/renew_session?session_id=' + STATE.session_id);
                        } else {
                            clear_renew_session_interval();
                        }
                    },
                    5 * 60 * 1000
                );

                document.getElementById('loading-page').classList.add('hidden');
                document.getElementById('intro-page').classList.remove('hidden');
                resize_map();
            });
        }

        function showNextPoint() {
            STATE.question_idx += 1;

            if (STATE.question_idx >= STATE.questions.length) {
                showResultsLoader();
                return;
            }

            const q = STATE.questions[STATE.question_idx];
            STATE.markers[STATE.question_idx] = L.marker(q, {icon:MARKER_Q}).addTo(MAP);

            setTimeout(function() {STATE.is_animating = false;}, 1500);
            MAP.flyTo(q, QUESTION_VIEW_ZOOM, {duration: 1.5});
        }

        function addAnswer(isJaffa) {
            if (STATE.is_animating) {
                console.warn("can't answer while still animating to next answer");
                return;
            }

            if (STATE.question_idx < 0 || STATE.question_idx > STATE.questions.length) {
                console.error("tried to add answer when no answers pending");
                return;
            }

            const marker = STATE.markers[STATE.question_idx];
            marker.setIcon(isJaffa ? MARKER_JAFFA : MARKER_TLV);

            // add a nice rewarding fading face
            const reward = L.marker(STATE.questions[STATE.question_idx], {icon:CAT_HEART}).addTo(MAP);
            reward.getElement().classList.add("fading-reward");

            STATE.answers[STATE.question_idx] = isJaffa;
            STATE.is_animating = true;

            setTimeout(() => {
                reward.remove();
            }, 1000);

            setTimeout(() => {
                document.getElementById(isJaffa ? "btn-jaf" : "btn-tlv").blur();
                showNextPoint();
            }, 600);
        }

        function showResultsLoader() {
            document.getElementById('question-page').classList.add('hidden');
            document.getElementById('results-loading-page').classList.remove('hidden');
            resize_map();

            clear_map_images_cache();

            MAP.setMinZoom(MIN_ZOOM_ALL_ANSWERS);
            MAP.flyToBounds(MAP_MAX_BOUNDS);

            const answers = STATE.answers.map((x) => x|0).join(',');
            
            // actually send to a server lol
            fetch(`/answer_session?session_id=${STATE.session_id}&answers=${answers}&get_all_answers=1`).then(function(response) {
                return response.json();
            }).then(function(o) {
                document.getElementById('results-loading-page').classList.add('hidden');
                document.getElementById('all-answers-page').classList.remove('hidden');
                resize_map();

                clear_renew_session_interval();

                // STATE.markers.map((m) => m.remove()); // remove quesion markers
                STATE.answer_markers = [[], []];
                for (let i = 0; i < o.features.length; i++) {
                    const f = o.features[i];

                    const [x, y] = f.geometry.coordinates;
                    const is_jaffa = f.properties.answer;

                    STATE.answer_markers[is_jaffa|0].push(
                        [y, x, 1]
                        // L.marker(
                        //     [y, x],
                        //     {icon: is_jaffa ? MARKER_JAFFA : MARKER_TLV}
                        // ).addTo(MAP)
                    );
                }

                HEAT_LAYER_TLV.setLatLngs(STATE.answer_markers[0]);
                HEAT_LAYER_JAFFA.setLatLngs(STATE.answer_markers[1]);
                

                // const tlv_point = 32.063602;
                // const jaf_point = 32.040754;
                // STATE.answer_markers = [];
                // STATE.answers = test__generateRandomPointsInPolygon(
                //     2000,
                //     TLVORJ_POLYGON_LOL.features[0].geometry.coordinates[0]
                // ).map(
                //     function([x, y]) {
                //         const tlv_chance = 
                //             (y > tlv_point) ? 1 : (
                //                 (y < jaf_point) ? 0 : (
                //                     (y - jaf_point) / (tlv_point - jaf_point)
                //                 )
                //             );
                //         const is_jaffa = (Math.random() >= tlv_chance);
                //         const coord = [y, x];
                //         // someday future me is going to look at this function and think "how dumb was i back then?"
                //         // that day could very well be tomorrow morning
                //         STATE.answer_markers.push(
                //             L.marker(coord, {icon:is_jaffa ? MARKER_JAFFA : MARKER_TLV}).addTo(MAP)
                //         );
                //         return {coord, is_jaffa};
                //     }
                // );
            });
        }

        document.getElementById('btn-tlv').addEventListener('click', event => { addAnswer(false); });
        document.getElementById('btn-jaf').addEventListener('click', event => { addAnswer(true);  });
        document.getElementById('btn-start').addEventListener('click', event => {
            document.getElementById('intro-page').classList.add('hidden');
            document.getElementById('question-page').classList.remove('hidden');
            resize_map();
            showNextPoint();
        });
        document.getElementById('btn-playagain').addEventListener('click', event => {
            playAgain();
        });
        setTimeout(() => loadQuestionsFromServer(), 0);


        function get_tile_src(url_template, {x, y, z}) {
            return url_template
                .replace("{z}", ""+Math.floor(z))
                .replace("{x}", ""+Math.floor(x))
                .replace("{y}", ""+Math.floor(y))
                // did you know? i really hope this is legally distinct from how the incomaptibly-licensed Leaflet source code does this check!
                .replace("{r}", (L.Browser.retina && "@2x") || "");
        }

        function preload_image_impl(src, onload) {
            const img = document.createElement('img');
            if (onload) {
                img.addEventListener('load', onload);
            }
            img.classList.add('preloaded');
            img.width = 1;
            img.height = 1;
            img.src = src;
            document.body.appendChild(img);

            return img;
        }

        function preload_map_image(xyz, mode_idx, onload) {
            PRELOADED_IMAGE_XYZ.push(xyz);

            PRELOADED_IMAGE_OBJS[mode_idx].push(preload_image_impl(get_tile_src(MAP_STYLES[mode_idx], xyz), onload));
        }

        function clear_map_images_cache() {
            PRELOADED_IMAGE_XYZ.splice(0, PRELOADED_IMAGE_XYZ.length);
            for (let mode_idx = 0; mode_idx < MAP_STYLES.length; mode_idx++) {
                PRELOADED_IMAGE_OBJS[mode_idx].splice(0, PRELOADED_IMAGE_OBJS[mode_idx].length);
            }
        }

        function refill_cache_for_mode(mode_idx) {
            const objs = PRELOADED_IMAGE_OBJS[mode_idx];

            if (objs.length < PRELOADED_IMAGE_XYZ.length) {
                for (let i = objs.length; i < PRELOADED_IMAGE_XYZ.length; i++) {
                    objs.push(
                        preload_image_impl(get_tile_src(
                            MAP_STYLES[mode_idx],
                            PRELOADED_IMAGE_XYZ[i]
                        ))
                    );
                }
            }
        }

        function long2tileFrac(lon,zoom) {
            return (lon+180)/360 * Math.pow(2,zoom);
        }
        function lat2tileFrac(lat,zoom) {
            return (
                1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI
            )/2 * Math.pow(2,zoom);
        }
        

        function get_viewport_size() {
            return [
                Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
                Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
            ];
        }

        function tile_neighborhood_for_coord(lat, long, zoom, hell_callback) {
            const center_xy = [long2tileFrac(long, zoom), lat2tileFrac(lat, zoom)];

            const [vw, vh] = get_viewport_size();
            const half_vcols = vw / TILE_SIZE / 2;
            const half_vrows = vh / TILE_SIZE / 2;

            const left = Math.floor(center_xy[0] - half_vcols);
            const top = Math.floor(center_xy[1] - half_vrows);
            const right = Math.floor(center_xy[0] + half_vcols);
            const bottom = Math.floor(center_xy[1] + half_vrows);

            const total_imgs = (right - left + 1) * (bottom - top + 1);

            for (let x = left; x <= right; x++) {
                for (let y = top; y <= bottom; y++) {
                    hell_callback({x, y, z: zoom}, total_imgs);
                }
            }
        }

        function preload_tile_neighborhood(lat, long, zoom, mode_idx, on_all_done) {
            let loaded_counter = 0;

            const coords = tile_neighborhood_for_coord(lat, long, zoom, function(xyz, total_imgs) {
                // it's called "hell_callback" because we are now officially in callback hell! {confetti emoji}
                preload_map_image(xyz, mode_idx, function(event) {
                    loaded_counter += 1;
                    console.log(`loaded image ${loaded_counter}/${total_imgs}`, event.target);

                    if (loaded_counter === total_imgs && on_all_done) {
                        on_all_done();
                    }
                });
            });
        }

        window.addEventListener("resize", function() {
            resize_map();
        });

        function resize_map() {
            setTimeout(function() {
                const ui = document.getElementById("main-ui");
                const map = document.getElementById("map");

                if ((ui.offsetTop + ui.offsetHeight) / window.innerHeight > 0.99) { // lol
                    map.style.bottom = ui.offsetHeight + "px";
                } else if (parseInt(map.style.bottom) !== 0) {
                    map.style.bottom = "0px";
                }
                
            }, 0);
        }

        
    })();
  </script>
</body>
</html>