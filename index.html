<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
  <style>
    #map {position: absolute; top: 0; right: 0; bottom: 0; left: 0;}
    .hidden {display: none !important;}
    /* .preloaded {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        pointer-events: none;
    } */
    #main-ui {
        display: block;
        z-index: 999;
        position: absolute;
        top: 25px;
        right: 25px;

        background-color: #fff;
        border: 1px solid #7f7f7f;
        padding: 40px 20px;

        text-align: center;

        transition: width 0.5s, height 0.5s;
    }
    
    #main-ui h1 {
        margin: 0 0 20px 0;
        font-size: 180%;
    }

    p {
        font-size: 120%;
    }

    .btn-pretty, .dramatic-or {
        font-size: 150%;
    }

    .btn-pretty {
        position: relative;
        display: inline-block;
        border: 2px solid black;
        border-radius: 10px;
        color: #fff;
        padding: 10px 30px;
        /* height: 50px; */
        /* line-height: 0; */


        transition: all 0.25s;

        cursor:pointer;

        text-shadow: 0px 0px 4px black;
    }

    #btn-tlv {
        background: #63acbe;/*rgb(155, 12, 1);*/
        margin-left: 15px;
    }
    #btn-jaf {
        background-color:#a9299c;/*rgb(17, 106, 60);*/
        margin-right: 15px;
    }

    #btn-start {
        background-color: #800;
    }

    #btn-tlv:hover, #btn-tlv:focus {
        background: #6fe0fc;
    }

    #btn-jaf:hover, #btn-jaf:focus {
        background-color: #bf53b4;
    }

    #btn-start:hover, #btn-start:focus {
        background-color: #d22;
    }

    .btn-pretty:active {
        top: 1px;
        left: 1px;
    }

    #btn-light-switch {
        background-color: transparent;
        background-image: url('/assets/switch_light.svg');
        background-size: contain;
        background-repeat: no-repeat;

        border: none;
        
        position: absolute;
        left: 5px;
        top: 5px;

        width: 74px;
        height: 20px;

        cursor: pointer;
    }

    /* .cat-heart {
        background-color: transparent;
        background-image: url('/assets/twemoji_catheart.svg');
        background-repeat: no-repeat;
        background-size: contain;

        width: 32px;
        height: 32px;
    } */

    .fading-reward {
        position:absolute;

        animation-duration: 1s;
        animation-name: fade;
        animation-iteration-count: 1;
        animation-timing-function:  ease-out;

        opacity: 0%;
    }

    @keyframes fade {
        from {
            top: 0;
            opacity: 100%;
        }

        to {
            top: -70px;
            opacity: 0%;
            display:none;
        }
    }

    #loading-page, #results-loading-page {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;

        width: 200px;
        min-height: 120px;

        font-size: 150%;
    }

    #loading-page > *,
    #results-loading-page > * {
        display: block;
    }

    .loading-indicator {
        width: 80px;
        height: 80px;
        border: 5px solid #333;
        border-radius: 100%;
        border-style: dashed;
        
        animation-duration: 5s;
        animation-name: rotate;
        animation-iteration-count: infinite;
        animation-timing-function:  linear;
    }

    @keyframes rotate {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }

    /* because this is plain css and not sass/less, i now have to duplicate the dark mode code */
    body.force-dark #main-ui {
        background-color: #000;
        color: #fff;
    }

    body.force-dark .btn-pretty {
        border-color: white;
    }

    body.force-dark #btn-light-switch {
        background-image: url('/assets/switch_dark.svg');
    }

    body.force-dark .loading-indicator {
        border-color: #fff;
    }

    @media (prefers-color-scheme: dark) {
        body:not(.force-light) #main-ui {
            background-color: #000;
            color: #fff;
        }

        body:not(.force-light) .btn-pretty {
            border-color: white;
        }

        body:not(.force-light) #btn-light-switch {
            background-image: url('/assets/switch_dark.svg');
        }

        body:not(.force-light) .loading-indicator {
            border-color: #fff;
        }
    }

    @media screen and (max-width: 760px) {
        #main-ui {
            top: 0;
            left: 0;
            right: 0;

            border-left: none;
            border-right: none;
            border-top: none;

            min-height: 120px;
        }

        #map { top: 120px; }
    }

    /* TODO: add media queries for smaller screens and all that jazz (glue the ui to bottom of screen?) */
  </style>
  <title>תל אביב או יפו?</title>
</head>
<body dir="ltr" lang="he">
  <div id="map"></div>
  
  <div id="main-ui" dir="rtl">
    <button id="btn-light-switch" aria-label="שינוי בין מצב יום ומצב לילה"></button>

    <section id="loading-page">
        <div class="loading-indicator"></div>
        <span><br>בטעינה...</span>
    </section>

    <section id="intro-page" class="hidden">
        <h1>תל אביב או יפו?</h1>
        <p>הגבול בין תל אביב לבין יפו לגמרי מטושטש, אבל אם נעבוד ביחד, נוכל למצוא אותו שוב!</p>
        <button class="btn-pretty" id="btn-start">שנתחיל?</button>
    </section>

    <section id="question-page" class="hidden">
        <h1>באיזו עיר הנקודה המסומנת?</h1>
        <button class="btn-pretty" id="btn-tlv">תל אביב</button>
        <span class="dramatic-or">או</span>
        <button class="btn-pretty" id="btn-jaf">יפו</button>
    </section>

    <section id="results-loading-page" class="hidden">
        <div class="loading-indicator"></div>
        <span><br>התשובות בעיבוד סופר מתקדם...</span>
    </section>

    <section id="all-answers-page" class="hidden">
        <h1>התשובות הסופיות</h1>
        <p>הנה התשובות של כולן.ם! נכון שעכשיו המצב הרבה יותר ברור?</p>
    </section>
    
</div>
  
  <script>
    
    // rtl plugin because 2020 is software hell
    // mapboxgl.setRTLTextPlugin('https://cdn.maptiler.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.1.2/mapbox-gl-rtl-text.js');

    (function() {
        const TLV_COLOR = '#63acbe';
        const JAFFA_COLOR = '#a9299c';

        let GLOB_is_dark_mode = false;
        let GLOB_is_dark_forced = false; // are we forcing light/dark mode currently?

        if (window.matchMedia) {
            const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)');

            // when we just initialize, set the dark mode flag to match browser settings
            GLOB_is_dark_mode = !!matchDarkMode.matches;

            matchDarkMode.addEventListener('change', event => {
                // but when the setting is changed on the fly, only update the flag
                // if the user hasn't touched the light switch
                if (GLOB_is_dark_forced) {
                    return;
                }

                GLOB_is_dark_mode = !!event.matches;
                onDarkModeSettingChanged();
            })
        }

        function onDarkModeSettingChanged() {
            // MAP.setStyle(MAP_STYLES[GLOB_is_dark_mode|0]);
            LAYER.setUrl(MAP_STYLES[GLOB_is_dark_mode|0]);
            if (STATE.question_idx <= 0) {
                refill_cache_for_mode(GLOB_is_dark_mode|0);
            }
        }

        document.getElementById('btn-light-switch').addEventListener('click', function(event) {
            // when the light switch is clicked:
            
            GLOB_is_dark_forced = true;
            GLOB_is_dark_mode = !GLOB_is_dark_mode;

            // force css to comply by adding class to the body:
            if (GLOB_is_dark_mode) {
                document.body.classList.add('force-dark');
                document.body.classList.remove('force-light');
            } else {
                document.body.classList.add('force-light');
                document.body.classList.remove('force-dark');
            }

            // and lastly, trigger the event that updates the map
            onDarkModeSettingChanged();
        });

        const STATE = {
            session_id: null,
            question_idx: -1,
            questions: null,
            markers: null,
            answers: null,
            answer_markers: null,
            show_results: false,

            is_animating: true,

            is_loading_results: false
        };

        const PRELOADED_IMAGE_XYZ  = window.PRELOADED_IMAGE_XYZ  = [];
        const PRELOADED_IMAGE_OBJS = window.PRELOADED_IMAGE_OBJS = [[], []];
        const TILE_SIZE = 512;
        const ZOOM_OFFSET = -1;

        const MIN_ZOOM_USUAL = 14;
        const MIN_ZOOM_ALL_ANSWERS = 13;
        const MAP_MAX_BOUNDS = L.latLngBounds(L.latLng(32.017357, 34.724041), L.latLng(32.159226, 34.867250));

        const MAP_STYLES = [
            'https://api.maptiler.com/maps/47c517fb-70bf-4903-89b4-2033ebbbedb1/{z}/{x}/{y}.png?key=XQ643Hu2aW2ClNCu8gL4', // light
            'https://api.maptiler.com/maps/a3b10cf0-43d5-4a06-aefd-226a3a02a57c/{z}/{x}/{y}.png?key=XQ643Hu2aW2ClNCu8gL4', // dark
        ];

        // initialize map and stuff
        const MAP = window.MAP = L.map('map', {
            zoomControl: false,
            bounceAtZoomLimits: false,

            minZoom: MIN_ZOOM_USUAL,
            maxZoom: 20,
            maxBounds: MAP_MAX_BOUNDS
        }).setView([32.058225, 34.770073], 14);
        const LAYER = L.tileLayer(
            MAP_STYLES[GLOB_is_dark_mode | 0],{
                tileSize: TILE_SIZE,
                zoomOffset: ZOOM_OFFSET,
                attribution: "\u003ca href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"\u003e\u0026copy; MapTiler\u003c/a\u003e \u003ca href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"\u003e\u0026copy; OpenStreetMap contributors\u003c/a\u003e",
                crossOrigin: true
        }).addTo(MAP);

        // DONE: fetch question list from server
        // done: mark answer and color marker on #btn-tlv or #btn-jaf clicked
        // DONE: send answers to server
        // DONE: show everyone's results at the end

        const QUESTION_VIEW_ZOOM = 16;

        const MARKER_Q = L.icon({
            iconUrl: '/assets/marker_q.svg',

            iconSize: [24, 30],
            iconAnchor: [12, 15],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_TLV = L.icon({
            iconUrl: '/assets/marker_tlv.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_JAFFA = L.icon({
            iconUrl: '/assets/marker_jaffa.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const CAT_HEART = L.icon({
            iconUrl: '/assets/twemoji_catheart.svg',
            
            iconSize: [36, 36],
            iconAnchor: [18, 18],
            popupAnchor: [0, 0] // ?
        });

        function loadQuestionsFromServer() {
            // DONE: actually load from an actual server lol
            // const MOCK_SERVER_DATA = {
            //     session_id: "66600000c0ffee00",
            //     questions: [
            //         [32.046846, 34.765445],
            //         [32.089870, 34.779854],
            //         [32.043159, 34.802404]
            //     ]
            // };

            fetch('/generate_session').then(function(response) {
                return response.json();
            }).then(function(o) {
                STATE.session_id = o.session_id;
                STATE.questions = o.points.map(([x, y]) => [y, x]);
                STATE.question_idx = -1; 
                STATE.answers = STATE.questions.map(() => null);
                STATE.markers = STATE.questions.map(() => null);

                const num_qs = STATE.questions.length;
                let preload_counter = 0;

                const start_ms = Date.now();

                for (const q of STATE.questions) {
                    preload_tile_neighborhood(
                        q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET, GLOB_is_dark_mode|0,
                        function() { // hello callback hell my old friend
                            preload_counter += 1; // haha gotta count till the end!!!!
                            if (preload_counter === num_qs && Date.now() - start_ms <= 1000) {
                                // load the outer zoom levels only if the inner zoom levels took less than 1s total
                                console.log('loading outer zoom levels');
                                for (const qq of STATE.questions) {
                                    preload_tile_neighborhood(q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET - 1, GLOB_is_dark_mode|0);
                                }
                            }
                        }
                    );
                    // preload_tile_neighborhood(q[0], q[1], QUESTION_VIEW_ZOOM - 2, GLOB_is_dark_mode|0);
                }

                document.getElementById('loading-page').classList.add('hidden');
                document.getElementById('intro-page').classList.remove('hidden');
            });
        }

        function showNextPoint() {
            STATE.question_idx += 1;

            if (STATE.question_idx >= STATE.questions.length) {
                showResultsLoader();
                return;
            }

            const q = STATE.questions[STATE.question_idx];

            // STATE.markers[STATE.question_idx] = new mapboxgl.Marker({
                // color: '#f5793a'
            // }).setLngLat(q).addTo(MAP);
            STATE.markers[STATE.question_idx] = L.marker(q, {icon:MARKER_Q}).addTo(MAP);
            setTimeout(function() {STATE.is_animating = false;}, 1500);
            MAP.flyTo(q, QUESTION_VIEW_ZOOM, {duration: 1.5});
        }

        function addAnswer(isJaffa) {
            if (STATE.is_animating) {
                console.warn("can't answer while still animating to next answer");
                return;
            }

            if (STATE.question_idx < 0 || STATE.question_idx > STATE.questions.length) {
                console.error("tried to add answer when no answers pending");
                return;
            }

            const marker = STATE.markers[STATE.question_idx];
            marker.setIcon(isJaffa ? MARKER_JAFFA : MARKER_TLV);

            const reward = L.marker(STATE.questions[STATE.question_idx], {icon:CAT_HEART}).addTo(MAP);
            reward.getElement().classList.add("fading-reward");
            // DONE: re-add fading cat face reward
            // DONE: re-remove fading cat face reward after animation is done
            // DONE: preload map tiles for next point????


            // i sure hope mapboxgljs never change the default marker svg lol
         //div.   svg    . g non0   . g trans  . g fill
            // el.firstChild.firstChild.firstChild.nextElementSibling.setAttribute("fill", isJaffa ? JAFFA_COLOR : TLV_COLOR);

            // add a nice rewarding fading face
            // const faceEl = document.createElement('div');
            // faceEl.classList.add("fading-reward", "cat-heart");
            // el.appendChild(faceEl);
            STATE.answers[STATE.question_idx] = isJaffa;
            STATE.is_animating = true;

            setTimeout(() => {
                reward.remove();
            }, 1000);

            setTimeout(() => {
                showNextPoint();
            }, 600);
        }

        // const TLVORJ_POLYGON_LOL = window.TLVORJ_POLYGON_LOL = {
        //     "type": "FeatureCollection",
        //     "generator": "overpass-ide",
        //     "copyright": "The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.",
        //     "timestamp": "2020-05-18T17:53:02Z",
        //     "features": [
        //         {"type": "Feature", "geometry": {
        //             "type": "Polygon",
        //             "coordinates": [[[34.7599523, 32.036474], [34.7609226, 32.0364774], [34.7616566, 32.0365736], [34.7627534, 32.0366045], [34.7637201, 32.0365475],
        //             [34.7648102, 32.0363907], [34.7655055, 32.0362449], [34.7661164, 32.0360102], [34.7693952, 32.0348599], [34.7702416, 32.0344503],
        //             [34.7708632, 32.0342258], [34.7716066, 32.0338981], [34.7726831, 32.0334717], [34.7726921, 32.0334869], [34.7743862, 32.0327793],
        //             [34.7766735, 32.0366922], [34.778101, 32.0386707], [34.7788194, 32.0382728], [34.7789424, 32.0383977], [34.7806878, 32.0404482],
        //             [34.7860013, 32.0468247], [34.7880801, 32.0467585], [34.788266, 32.0462139], [34.7893175, 32.0440806], [34.7893738, 32.0441019],
        //             [34.7896112, 32.0435302], [34.7905549, 32.041484], [34.7917614, 32.0408878], [34.7942195, 32.0402664], [34.7954583, 32.0400678],
        //             [34.7968048, 32.0397277], [34.7980261, 32.0392118], [34.7988374, 32.0387686], [34.8006752, 32.0376804], [34.8015691, 32.037099],
        //             [34.802537, 32.036619], [34.8037814, 32.036054], [34.8054746, 32.0353502], [34.8072519, 32.0345527], [34.8080262, 32.0367907],
        //             [34.8076433, 32.0369006], [34.807918, 32.0376697], [34.8082863, 32.0375057], [34.8084364, 32.0381126], [34.8089343, 32.0392335],
        //             [34.8097489, 32.0415382], [34.8121926, 32.0408139], [34.8123315, 32.0408265], [34.812423, 32.0409164], [34.8138129, 32.0446013],
        //             [34.8132415, 32.0446939], [34.8137764, 32.0467277], [34.8138145, 32.0469971], [34.813906, 32.0476435], [34.8139279, 32.048543],
        //             [34.8138801, 32.0503151], [34.8138417, 32.0506746], [34.8136676, 32.0512112], [34.8133778, 32.0517542], [34.8130027, 32.0523516],
        //             [34.8125487, 32.0529485], [34.8121486, 32.053412], [34.8117758, 32.0537654], [34.8115162, 32.0540116], [34.8110639, 32.0543902],
        //             [34.8104268, 32.0548598], [34.8110273, 32.055961], [34.8112814, 32.0565693], [34.8116451, 32.0578768], [34.8117959, 32.0586318],
        //             [34.8105739, 32.0588432], [34.8107133, 32.0597083], [34.8094387, 32.0599935], [34.8086379, 32.0602384], [34.8080559, 32.0604513],
        //             [34.8076154, 32.0606534], [34.8070291, 32.060979], [34.8066949, 32.0611944], [34.8061407, 32.0616267], [34.8055958, 32.0621655],
        //             [34.8058771, 32.0623597], [34.8057569, 32.0629088], [34.8054755, 32.0632828], [34.8052249, 32.0636844], [34.8049405, 32.0642392],
        //             [34.8047126, 32.0648157], [34.8045815, 32.0652271], [34.8044923, 32.0656284], [34.8038597, 32.065577], [34.8037845, 32.0661294],
        //             [34.8028101, 32.0660468], [34.802506, 32.0691447], [34.8024177, 32.0695835], [34.8023099, 32.0697888], [34.8021218, 32.0699782],
        //             [34.802566, 32.0704561], [34.8023866, 32.0706084], [34.8022498, 32.0707762], [34.8009232, 32.0725349], [34.800599, 32.0729257],
        //             [34.8021281, 32.0767609], [34.8021236, 32.0771463], [34.8019335, 32.0777139], [34.8016683, 32.0779354], [34.8013171, 32.0781629],
        //             [34.799323, 32.0792031], [34.7988821, 32.0794049], [34.7987341, 32.0795438], [34.7978591, 32.0802108], [34.7981179, 32.0807967],
        //             [34.798485, 32.0808437], [34.7986342, 32.0809656], [34.7990386, 32.0811144], [34.7993188, 32.08116], [34.7997927, 32.0811735],
        //             [34.7998964, 32.0811793], [34.8000201, 32.0811905], [34.8000483, 32.0816511], [34.8000005, 32.0819082], [34.7998664, 32.082227],
        //             [34.7995713, 32.0827641], [34.7994277, 32.0832128], [34.7994041, 32.0835459], [34.7994462, 32.0837499], [34.7995258, 32.0839278],
        //             [34.7993912, 32.0840223], [34.7991223, 32.0843933], [34.7992975, 32.0848706], [34.8001094, 32.0866451], [34.800569, 32.0877273],
        //             [34.8011405, 32.0893632], [34.8013086, 32.0901515], [34.8017854, 32.0929295], [34.8021018, 32.0933204], [34.8022135, 32.0934054],
        //             [34.8028246, 32.0927597], [34.8031273, 32.0922878], [34.8034556, 32.0916111], [34.8038951, 32.0911981], [34.8042194, 32.0910073],
        //             [34.8044838, 32.0909248], [34.8048029, 32.0911114], [34.8049955, 32.0911382], [34.8050141, 32.0910803], [34.8053706, 32.0911818],
        //             [34.8053374, 32.091273], [34.8058862, 32.0914028], [34.8058935, 32.0912055], [34.806456, 32.0912288], [34.8070539, 32.0911658],
        //             [34.8068813, 32.0899076], [34.8068822, 32.0898141], [34.8069582, 32.0897763], [34.8086708, 32.0907686], [34.8089931, 32.0909122],
        //             [34.8093237, 32.0909767], [34.8087775, 32.0933347], [34.8087024, 32.0935594], [34.8086749, 32.0939835], [34.8085686, 32.0942757],
        //             [34.8085608, 32.0943945], [34.808662, 32.0943992], [34.8087026, 32.0941008], [34.8087785, 32.0943486], [34.8091299, 32.0947844],
        //             [34.8094084, 32.0949697], [34.8097403, 32.0950932], [34.8097055, 32.0963193], [34.810086, 32.0963044], [34.8104865, 32.0962473],
        //             [34.8110735, 32.0960829], [34.8115477, 32.0959215], [34.8119004, 32.0957591], [34.8122325, 32.0956659], [34.8124035, 32.0956553],
        //             [34.8128844, 32.0957435], [34.8135271, 32.0959648], [34.8137942, 32.0960919], [34.8142583, 32.0963706], [34.8144566, 32.0965319],
        //             [34.8148322, 32.096958], [34.8152043, 32.0974585], [34.8153969, 32.097999], [34.8155343, 32.0981483], [34.8156194, 32.0981767],
        //             [34.8160326, 32.0981603], [34.8169785, 32.0980122], [34.8174285, 32.0978877], [34.8182152, 32.097794], [34.8185537, 32.0975767],
        //             [34.8186435, 32.0974742], [34.8188486, 32.0969679], [34.8188463, 32.0964914], [34.8189042, 32.0963474], [34.8189924, 32.0962497],
        //             [34.8191824, 32.0961513], [34.8193251, 32.0961108], [34.8194539, 32.0961119], [34.8196675, 32.0961641], [34.8199795, 32.0962867],
        //             [34.8203379, 32.0965979], [34.8214132, 32.0977876], [34.8216428, 32.0981662], [34.8219293, 32.098512], [34.8224614, 32.0988262],
        //             [34.8225662, 32.0989676], [34.8226213, 32.0991476], [34.8225803, 32.0994933], [34.8223843, 32.0998159], [34.8221124, 32.1000977],
        //             [34.8214612, 32.1005446], [34.8213141, 32.1007072], [34.821146, 32.1009504], [34.8211678, 32.1011976], [34.8213526, 32.1014203],
        //             [34.8215995, 32.1015941], [34.8221085, 32.1018121], [34.8225309, 32.1018962], [34.8231945, 32.1018982], [34.823553, 32.1019991],
        //             [34.82419, 32.1023374], [34.824362, 32.1025048], [34.8243891, 32.1025877], [34.8243857, 32.1026734], [34.824326, 32.1027578],
        //             [34.8239109, 32.1029504], [34.8235091, 32.1030326], [34.8231771, 32.1031533], [34.8230009, 32.1032952], [34.8229023, 32.1034659],
        //             [34.8229568, 32.1036267], [34.8230358, 32.10373], [34.8232227, 32.1038817], [34.8234574, 32.1040036], [34.8238356, 32.1042752],
        //             [34.824062, 32.1043751], [34.8243509, 32.1044352], [34.8248109, 32.1046372], [34.8250307, 32.1047844], [34.8251783, 32.1049404],
        //             [34.8270604, 32.1053496], [34.8274083, 32.1055175], [34.8276484, 32.1055761], [34.8278538, 32.1056264], [34.8287154, 32.105837],
        //             [34.829669, 32.1058398], [34.8307318, 32.1057934], [34.8319084, 32.1056474], [34.8325033, 32.1054987], [34.8334364, 32.1053165],
        //             [34.8358728, 32.1051637], [34.8360518, 32.1052103], [34.8370923, 32.1056993], [34.8377663, 32.1059198], [34.8388579, 32.1063756],
        //             [34.8391843, 32.1065749], [34.8397401, 32.1069913], [34.8398967, 32.1070285], [34.8400566, 32.10703], [34.8411167, 32.1068781],
        //             [34.8413234, 32.1068658], [34.8414609, 32.1069067], [34.8417144, 32.1071222], [34.8418284, 32.1072831], [34.8421244, 32.1079287],
        //             [34.8422498, 32.1081365], [34.8424008, 32.1082559], [34.8425817, 32.108346], [34.8427541, 32.108396], [34.8429511, 32.1084192],
        //             [34.8433886, 32.1084182], [34.8439359, 32.1082845], [34.8439749, 32.1082697], [34.8445695, 32.1080439], [34.8454175, 32.1076388],
        //             [34.8461924, 32.1070143], [34.8464509, 32.1067298], [34.8466399, 32.1066284], [34.8467459, 32.1066083], [34.8472704, 32.1066121],
        //             [34.8476281, 32.1066784], [34.8479118, 32.1067874], [34.8483472, 32.1070418], [34.8486193, 32.1071158], [34.8489393, 32.1071083],
        //             [34.8492904, 32.1070252], [34.8507066, 32.1135971], [34.8507523, 32.1136042], [34.8517177, 32.1177251], [34.8520325, 32.118816],
        //             [34.8522454, 32.1194098], [34.852025, 32.1194489], [34.8516994, 32.1195568], [34.8515269, 32.1196854], [34.8512412, 32.1197928],
        //             [34.851069, 32.119763], [34.8509559, 32.1198084], [34.8502992, 32.1198229], [34.8503657, 32.1203348], [34.8488717, 32.1186995],
        //             [34.8485139, 32.118774], [34.8485243, 32.119075], [34.846858, 32.1193465], [34.846883, 32.1194824], [34.8462366, 32.1196508],
        //             [34.8452092, 32.119693], [34.8442486, 32.1196987], [34.8442445, 32.1200059], [34.8443879, 32.1204688], [34.8438202, 32.1206932],
        //             [34.8434454, 32.1208411], [34.8435433, 32.1210107], [34.8422433, 32.121428], [34.8418771, 32.121516], [34.8417407, 32.1235282],
        //             [34.8412071, 32.1237045], [34.8410056, 32.1242673], [34.8399004, 32.1242641], [34.8398841, 32.1243433], [34.8399484, 32.126432],
        //             [34.8367315, 32.1264412], [34.8371684, 32.1272213], [34.8372908, 32.1277045], [34.8357802, 32.1277007], [34.8357844, 32.1281295],
        //             [34.8333664, 32.1283981], [34.8333937, 32.1285305], [34.8287032, 32.1287141], [34.8278424, 32.1278626], [34.8261645, 32.1278625],
        //             [34.8272671, 32.1296665], [34.827578, 32.1303725], [34.8195006, 32.1306853], [34.8199065, 32.1295424], [34.8217791, 32.1258882],
        //             [34.8220221, 32.1255311], [34.8232667, 32.1246789], [34.8232264, 32.1233459], [34.8180476, 32.1237857], [34.8147383, 32.1240989],
        //             [34.8103851, 32.124401], [34.8101912, 32.1244147], [34.8101758, 32.1260259], [34.8098512, 32.1273061], [34.8089909, 32.1284068],
        //             [34.8082015, 32.1290689], [34.807171, 32.1297416], [34.8058114, 32.1303143], [34.8044526, 32.1307057], [34.8034722, 32.1308688],
        //             [34.8027372, 32.1309205], [34.8016523, 32.1308327], [34.800819, 32.1307339], [34.799845, 32.1305354], [34.7986357, 32.1300646],
        //             [34.7979102, 32.1296655], [34.7971035, 32.1290095], [34.7967891, 32.1286557], [34.7958435, 32.1286938], [34.7969151, 32.1333335],
        //             [34.7970983, 32.1338999], [34.7973073, 32.1343453], [34.7986886, 32.1368522], [34.7989006, 32.1371663], [34.8005848, 32.1392238],
        //             [34.8010857, 32.1399485], [34.8014463, 32.1405792], [34.8018443, 32.1414383], [34.802672, 32.1439795], [34.8024176, 32.1440272],
        //             [34.8022547, 32.1440567], [34.7980258, 32.1448395], [34.7969768, 32.1450129], [34.7919881, 32.1459706], [34.7915488, 32.1460721],
        //             [34.7894874, 32.1465478], [34.7876295, 32.1469766], [34.7865051, 32.1434619], [34.7754309, 32.1141553], [34.7715002, 32.1100105],
        //             [34.7712454, 32.1036024], [34.7671088, 32.0966363], [34.7662195, 32.0951385], [34.7636982, 32.0868051], [34.7591143, 32.0716524],
        //             [34.7540176, 32.0605762], [34.7509753, 32.0591076], [34.7480748, 32.0577074], [34.7407703, 32.0479843], [34.7407755, 32.0385723],
        //             [34.739131, 32.0337564], [34.7422018, 32.0329711], [34.7423195, 32.033133], [34.7424309, 32.0331262], [34.7430682, 32.0330872],
        //             [34.7433235, 32.0330003], [34.7433495, 32.0330387], [34.7434054, 32.0330171], [34.7439781, 32.0327579], [34.7439347, 32.0327208],
        //             [34.7441624, 32.0325724], [34.7441252, 32.0325597], [34.7457522, 32.0316682], [34.7498687, 32.0293437], [34.7508466, 32.0305994],
        //             [34.7519117, 32.0305432], [34.7525573, 32.0304308], [34.7526338, 32.0306149], [34.7527868, 32.0306235], [34.7528557, 32.0310052],
        //             [34.7545649, 32.0307511], [34.7546111, 32.0309709], [34.7546464, 32.0309666], [34.7546974, 32.0312306], [34.755268, 32.0311522],
        //             [34.7553373, 32.031346], [34.755535, 32.0321908], [34.7554573, 32.0322024], [34.7555189, 32.0325044], [34.7557272, 32.0324728],
        //             [34.7559292, 32.0335029], [34.7594835, 32.0329286], [34.7594073, 32.033702], [34.7594103, 32.034426], [34.7594501, 32.0348412],
        //             [34.7595812, 32.0355455], [34.7597797, 32.0361003], [34.7599523, 32.036474]]]
        //         }}
        //     ]
        // };

        // window.test__generateRandomPointsInPolygon = function test__generateRandomPointsInPolygon(numpoints, polygon) {
        //     const [[min_x, min_y], [max_x, max_y]] = test__findPolygonBbox(polygon);

        //     const result = [];

        //     for (let i = 0; i < numpoints; i++) {
        //         let x = null,
        //             y = null;
                
        //         do {
        //             x = Math.random() * (max_x - min_x) + min_x;
        //             y = Math.random() * (max_y - min_y) + min_y;
        //         } while(!test__isPointInPolygon(polygon, [x, y]));

        //         result.push([x, y]);
        //     }

        //     return result;
        // }

        // function test__findPolygonBbox(polygon) {
        //     let min_x = null,
        //         min_y = null,
        //         max_x = null,
        //         max_y = null;
            
        //     for (let i = 0; i < polygon.length; i++) {
        //         const [x, y] = polygon[i];

        //         if (min_x === null || min_x > x) {
        //             min_x = x;
        //         }

        //         if (min_y === null || min_y > y) {
        //             min_y = y;
        //         }

        //         if (max_x === null || max_x < x) {
        //             max_x = x;
        //         }

        //         if (max_y === null || max_y < y) {
        //             max_y = y;
        //         }
        //     }

        //     return [[min_x, min_y], [max_x, max_y]];
        // }

        // function test__isPointInPolygon(polygon, point) {
        //     //A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
        //     let odd = false;
        //     //For each edge (In this case for each point of the polygon and the previous one)
        //     for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        //         //If a line from the point into infinity crosses this edge
        //         if (((polygon[i][1] > point[1]) !== (polygon[j][1] > point[1])) // One point needs to be above, one below our y coordinate
        //             // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
        //             && (point[0] < ((polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]))) {
        //             // Invert odd
        //             odd = !odd;
        //         }
        //         j = i;

        //     }
        //     //If the number of crossings was odd, the point is in the polygon
        //     return odd;
        // };

        function showResultsLoader() {
            document.getElementById('question-page').classList.add('hidden');
            document.getElementById('results-loading-page').classList.remove('hidden');

            clear_map_images_cache();

            MAP.setMinZoom(MIN_ZOOM_ALL_ANSWERS);
            MAP.flyToBounds(MAP_MAX_BOUNDS);

            const answers = STATE.answers.map((x) => x|0).join(',');
            
            // DONE: actually send to a server lol
            fetch(`/answer_session?session_id=${STATE.session_id}&answers=${answers}&get_all_answers=1`).then(function(response) {
                return response.json();
            }).then(function(o) {
                document.getElementById('results-loading-page').classList.add('hidden');
                document.getElementById('all-answers-page').classList.remove('hidden');

                // DONE: remove question markers?
                STATE.markers.map((m) => m.remove()); // remove quesion markers

                // DONE: replace this with like actual answers or something
                STATE.answer_markers = [];
                for (let i = 0; i < o.features.length; i++) {
                    const f = o.features[i];

                    const [x, y] = f.geometry.coordinates;
                    const is_jaffa = f.properties.answer;

                    STATE.answer_markers.push(
                        L.marker(
                            [y, x],
                            {icon: is_jaffa ? MARKER_JAFFA : MARKER_TLV}
                        ).addTo(MAP)
                    );
                }

                // const tlv_point = 32.063602;
                // const jaf_point = 32.040754;
                // STATE.answer_markers = [];
                // STATE.answers = test__generateRandomPointsInPolygon(
                //     2000,
                //     TLVORJ_POLYGON_LOL.features[0].geometry.coordinates[0]
                // ).map(
                //     function([x, y]) {
                //         const tlv_chance = 
                //             (y > tlv_point) ? 1 : (
                //                 (y < jaf_point) ? 0 : (
                //                     (y - jaf_point) / (tlv_point - jaf_point)
                //                 )
                //             );
                //         const is_jaffa = (Math.random() >= tlv_chance);
                //         const coord = [y, x];
                //         // someday future me is going to look at this function and think "how dumb was i back then?"
                //         // that day could very well be tomorrow morning
                //         STATE.answer_markers.push(
                //             L.marker(coord, {icon:is_jaffa ? MARKER_JAFFA : MARKER_TLV}).addTo(MAP)
                //         );
                //         return {coord, is_jaffa};
                //     }
                // );
            });
        }

        document.getElementById('btn-tlv').addEventListener('click', event => { addAnswer(false); });
        document.getElementById('btn-jaf').addEventListener('click', event => { addAnswer(true);  });
        document.getElementById('btn-start').addEventListener('click', event => {
            document.getElementById('intro-page').classList.add('hidden');
            document.getElementById('question-page').classList.remove('hidden');
            showNextPoint();
        });
        setTimeout(() => loadQuestionsFromServer(), 0);


        function get_tile_src(url_template, {x, y, z}) {
            return url_template
                .replace("{z}", ""+Math.floor(z))
                .replace("{x}", ""+Math.floor(x))
                .replace("{y}", ""+Math.floor(y));
        }

        function preload_image_impl(src, onload) {
            const img = document.createElement('img');
            if (onload) {
                img.addEventListener('load', onload);
            }
            img.classList.add('preloaded');
            img.width = 1;
            img.height = 1;
            img.src = src;
            document.body.appendChild(img);

            return img;
        }

        function preload_map_image(xyz, mode_idx, onload) {
            PRELOADED_IMAGE_XYZ.push(xyz);

            PRELOADED_IMAGE_OBJS[mode_idx].push(preload_image_impl(get_tile_src(MAP_STYLES[mode_idx], xyz), onload));
        }

        function clear_map_images_cache() {
            PRELOADED_IMAGE_XYZ.splice(0, PRELOADED_IMAGE_XYZ.length);
            for (let mode_idx = 0; mode_idx < MAP_STYLES.length; mode_idx++) {
                PRELOADED_IMAGE_OBJS[mode_idx].splice(0, PRELOADED_IMAGE_OBJS[mode_idx].length);
            }
        }

        function refill_cache_for_mode(mode_idx) {
            const objs = PRELOADED_IMAGE_OBJS[mode_idx];

            if (objs.length < PRELOADED_IMAGE_XYZ.length) {
                for (let i = objs.length; i < PRELOADED_IMAGE_XYZ.length; i++) {
                    objs.push(
                        preload_image_impl(get_tile_src(
                            MAP_STYLES[mode_idx],
                            PRELOADED_IMAGE_XYZ[i]
                        ))
                    );
                }
            }
        }

        function long2tileFrac(lon,zoom) {
            return (lon+180)/360 * Math.pow(2,zoom);
        }
        function lat2tileFrac(lat,zoom) {
            return (
                1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI
            )/2 * Math.pow(2,zoom);
        }
        

        function get_viewport_size() {
            return [
                Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
                Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
            ];
        }

        function tile_neighborhood_for_coord(lat, long, zoom, hell_callback) {
            const center_xy = [long2tileFrac(long, zoom), lat2tileFrac(lat, zoom)];

            const [vw, vh] = get_viewport_size();
            const half_vcols = vw / TILE_SIZE / 2;
            const half_vrows = vh / TILE_SIZE / 2;

            const left = Math.floor(center_xy[0] - half_vcols);
            const top = Math.floor(center_xy[1] - half_vrows);
            const right = Math.floor(center_xy[0] + half_vcols);
            const bottom = Math.floor(center_xy[1] + half_vrows);

            const total_imgs = (right - left + 1) * (bottom - top + 1);

            for (let x = left; x <= right; x++) {
                for (let y = top; y <= bottom; y++) {
                    hell_callback({x, y, z: zoom}, total_imgs);
                }
            }
        }

        function preload_tile_neighborhood(lat, long, zoom, mode_idx, on_all_done) {
            let loaded_counter = 0;

            const coords = tile_neighborhood_for_coord(lat, long, zoom, function(xyz, total_imgs) {
                // it's called "hell_callback" because we are now officially in callback hell! {confetti emoji}
                preload_map_image(xyz, mode_idx, function(event) {
                    loaded_counter += 1;
                    console.log(`loaded image ${loaded_counter}/${total_imgs}`, event.target);

                    if (loaded_counter === total_imgs && on_all_done) {
                        on_all_done();
                    }
                });
            });
        }

        
    })();
  </script>
</body>
</html>