<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
  <style>
    @font-face {
        font-family: 'Heebo';
        src: url(/assets/Heebo-Regular.ttf) format('truetype');
    }
    body, .btn-pretty {
        font-family: 'Heebo', sans-serif;
        background-color: #fff;
        color: #000;
    }
    .preloaded {
        position: absolute;
        top: 0;
        left: 0;
        width: 1px;
        height: 1px;
        z-index: -999;
    }
    #map {position: absolute; top: 0; right: 0; bottom: 0; left: 0;}
    .hidden {display: none !important;}
    .no-bg-no-border {background: none !important; border: none !important; /* don't ask */}
    #main-ui {
        display: block;
        z-index: 999;
        position: absolute;
        top: 25px;
        right: 25px;

        background-color: #fff;
        border: 1px solid #7f7f7f;
        padding: 40px 20px;

        text-align: center;

        transition: width 0.5s, height 0.5s;
    }
    
    #main-ui h1 {
        margin: 0 0 20px 0;
        font-size: 180%;
    }

    p {
        font-size: 120%;
    }

    .btn-pretty, .dramatic-or {
        font-size: 150%;
    }

    .btn-pretty {
        position: relative;
        display: inline-block;
        border: 2px solid black;
        border-radius: 10px;
        color: #fff;
        padding: 10px 30px;


        transition: all 0.25s;

        cursor:pointer;

        text-shadow: 0px 0px 4px black;
    }

    #btn-tlv {
        background: #63acbe;
        margin-left: 15px;
    }
    #btn-jaf {
        background-color:#a9299c;
        margin-right: 15px;
    }

    #btn-tlv:disabled,
    #btn-jaf:disabled {
        background: #777;
        color: #444;
        text-shadow: none;
    }

    .btn-red {
        background-color: #800;
    }

    .btn-blue {
        background-color: #0054ae;
    }

    @media (hover: hover) and (pointer: fine) {
        #btn-tlv:not(:disabled):hover, #btn-tlv:not(:disabled):focus {
            background: #6fe0fc;
        }

        #btn-jaf:not(:disabled):hover, #btn-jaf:not(:disabled):focus {
            background-color: #bf53b4;
        }

        .btn-red:not(:disabled):hover, .btn-red:not(:disabled):focus {
            background-color: #d22;
        }

        .btn-blue:not(:disabled):hover, .btn-blue:not(:disabled):focus {
            background-color: #70ade3;
        }
    }

    .btn-pretty:not(:disabled):active {
        top: 1px;
        left: 1px;
    }

    #btn-light-switch {
        background-color: transparent;
        background-image: url('/assets/switch_light.svg');
        background-size: contain;
        background-repeat: no-repeat;

        border: none;
        
        position: absolute;
        left: 5px;
        top: 5px;

        width: 74px;
        height: 20px;

        cursor: pointer;
    }

    .fading-reward {
        position:absolute;

        animation-duration: 1s;
        animation-name: fade-and-elevate;
        animation-iteration-count: 1;
        animation-timing-function:  ease-out;

        opacity: 0%;
    }

    @keyframes fade-and-elevate {
        from {
            top: 0;
            opacity: 100%;
        }

        to {
            top: -70px;
            opacity: 0%;
            display:none;
        }
    }

    @media screen and (prefers-reduced-motion: reduce) {
        .fading-reward {
            animation-name: fade;
        }

        @keyframes fade {
            from {
                top: 0;
                opacity: 100%;
            }

            to {
                top: 0px;
                opacity: 0%;
                display:none;
            }
        }
    }

    .pulsating {
        animation-duration: 1.5s;
        animation-name: pulse;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
        animation-direction: alternate;
    }

    @keyframes pulse {
        from {
            transform: scale(1.0);
        }

        to {
            transform: scale(0.6);
        }
    }

    @media screen and (prefers-reduced-motion: reduce) {
        .pulsating {
            animation: none !important; /* yeah i think this one's expendable */
        }
    }

    #loading-page, #results-loading-page {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;

        min-width: 250px;
        min-height: 120px;

        padding-top: 20px;

        font-size: 150%;
    }

    #loading-page > *,
    #results-loading-page > * {
        display: block;
    }

    .loading-indicator {
        width: 80px;
        height: 80px;
        background-color: transparent;
        background-image: url('/assets/loading.svg');
        background-size: contain;
        background-repeat: no-repeat;
        
        animation-duration: 5s;
        animation-name: rotate;
        animation-iteration-count: infinite;
        animation-timing-function:  linear;
    }

    @media screen and (prefers-reduced-motion: reduce) {
        .loading-indicator {
            animation: none !important;
        }
    }

    @keyframes rotate {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }

    table.tlvorj-maplegend {
        min-width: 360px;
        border: 0;
        margin-bottom: 20px;
        text-align: center;
    }

    table.tlvorj-maplegend th {
        font-size: 120%;
        font-weight: normal;
    }

    table.tlvorj-maplegend td img,
    table.tlvorj-maplegend td canvas {
        vertical-align: middle;

        /* gee i sure hope this kludge doesn't look terrible on exactly half of the browser/os combinations: */
        position: relative;
        bottom: 2px;
    }

    .legend-centerer {
        display: inline-block;
        text-align: right;
    }

    #error-page p {
        font-size: 180%;
        margin-top: 10px;
    }

    #main-ui > .credits {
        position: absolute;
        left: 4px;
        bottom: 2px;

        font-size: 80%;
    }

    #main-ui > .privacy {
        position: absolute;
        right: 4px;
        bottom: 2px;

        font-size: 80%;
    }

    #main-ui a:link,
    #main-ui a:visited {
        color: #777;
    }

    #main-ui a:active {
        color: #bbb;
    }

    @media (hover: hover) and (pointer: fine) {
        #main-ui a:hover {
            color: #aaa;
            text-decoration: dotted underline;
        }
    }

    /* because this is plain css and not sass/less, i now have to duplicate the dark mode code */
    body.force-dark,
    body.force-dark #main-ui {
        background-color: #000;
        color: #fff;
    }

    body.force-dark .btn-pretty {
        border-color: white;
    }

    body.force-dark #btn-light-switch {
        background-image: url('/assets/switch_dark.svg');
    }

    body.force-dark .loading-indicator {
        background-image: url('/assets/loading_darkmode.svg');
    }

    body.force-dark #main-ui a:link,
    body.force-dark #main-ui a:visited {
        color: #bbb;
    }

    body.force-dark #main-ui a:active {
        color: #ddd;
    }

    @media (hover: hover) and (pointer: fine) {
        body.force-dark #main-ui a:hover {
            color: #ddd;
        }
    }

    @media (prefers-color-scheme: dark) {
        body:not(.force-light),
        body:not(.force-light) #main-ui {
            background-color: #000;
            color: #fff;
        }

        body:not(.force-light) .btn-pretty {
            border-color: white;
        }

        body:not(.force-light) #btn-light-switch {
            background-image: url('/assets/switch_dark.svg');
        }

        body:not(.force-light) .loading-indicator {
            background-image: url('/assets/loading_darkmode.svg');
        }

        body:not(.force-light) #main-ui a:link,
        body:not(.force-light) #main-ui a:visited {
            color: #bbb;
        }

        body:not(.force-light) #main-ui a:active {
            color: #ddd;
        }
    }

    @media (prefers-color-scheme: dark) and (hover: hover) and (pointer: fine) {
        body:not(.force-light) #main-ui a:hover {
            color: #ddd;
        }
    }

    @media screen and (max-width: 760px), (display-mode: standalone) {
        #main-ui {
            display: flex;
            justify-content: center;
            align-items: center;

            top: unset;
            bottom: 0;
            left: 0;
            right: 0;

            border-left: none;
            border-right: none;
            border-bottom: none;

            box-sizing: border-box;
            padding: 24px 20px 30px 20px; /* down from padding: 40px 20px; */

            min-height: 240px;
        }

        p {
            margin: 10px 0; /* down from the default 1em = 19.2px in this context */
        }

        #map { 
            bottom: 240px;
            top: 0;
        }
    }

    @media (display-mode: standalone) {
        /* standalone webapps on ios have the little white line at the bottom;
           the additional padding makes sure the credit and privacy policy link aren't under it */
        #main-ui {
            padding-bottom: 43px;
        }

        #main-ui > .credits,
        #main-ui > .privacy {
            bottom: 13px;
        }
    }

    @media screen and (max-width: 400px) {
        table.tlvorj-maplegend {
            min-width: unset;
        }
    }

    @media screen and (max-width: 350px) {
        /* i had an iphone se up until nov 2019 and i know it's still supported as of now (dec 2020)
           so i think it's not too much to plan for those 3 ppl who might visit this site with tiny phones */
        
        .dramatic-or {
            display: none;
        }
    }
  </style>
  <title>תל אביב או יפו?</title>
</head>
<body dir="ltr" lang="he">
  <div id="map"></div>
  
  <div id="main-ui" dir="rtl">
    <button id="btn-light-switch" aria-label="שינוי בין מצב יום ומצב לילה" title="שינוי בין מצב יום ומצב לילה"></button>

    <section id="loading-page">
        <div class="loading-indicator"></div>
        <span><br>בטעינה...</span>
    </section>

    <section id="intro-page" class="hidden">
        <h1>תל אביב או יפו?</h1>
        <p>הגבול בין תל אביב לבין יפו לגמרי מטושטש, אבל אם נעבוד ביחד, נוכל למצוא אותו שוב!</p>
        <button class="btn-pretty btn-red" id="btn-start">שנתחיל?</button>
    </section>

    <section id="question-page" class="hidden">
        <h1>באיזו עיר נמצאת הנקודה המסומנת?</h1>
        <button class="btn-pretty" id="btn-tlv" disabled>תל אביב</button>
        <span class="dramatic-or">או</span>
        <button class="btn-pretty" id="btn-jaf" disabled>יפו</button>
    </section>

    <section id="results-loading-page" class="hidden">
        <div class="loading-indicator"></div>
        <span><br>התשובות עוברות עיבוד סופר מתקדם...</span>
    </section>

    <section id="error-page" class="hidden">
        <p>אוי לא! היתה שגיאה כלשהי :(</p>
        <button class="btn-pretty btn-red" id="btn-retry">שננסה שוב?</button>
    </section>

    <section id="all-answers-page" class="hidden">
        <h1>התשובות הסופיות</h1>
        <table class="tlvorj-maplegend">
            <tr>
                <th>את.ה ענית:</th>
                <th>אחרות ואחרים ענו:</th>
            </tr>
            <tr>
                <td>
                    <div class="legend-centerer">
                        <img src="/assets/marker_tlv.svg" alt="ריבוע תכלת עם מסגרת שחורה" width="22" height="22"> &mdash; תל אביב<br>
                        <img src="/assets/marker_jaffa.svg" alt="עיגול סגול עם מסגרת לבנה" width="22" height="22"> &mdash; יפו
                    </div>
                </td>
                <td>
                    <div class="legend-centerer">
                        <canvas id="legend-other-tlv" alt="עיגול תכלת מטושטש" width="22" height="22"></canvas> &mdash; תל אביב<br>
                        <canvas id="legend-other-jaf" alt="עיגול סגול מטושטש" width="22" height="22"></canvas> &mdash; יפו
                    </div>
                </td>
            </tr>
        </table>
        <button class="btn-pretty btn-blue" id="btn-playagain">עוד הפעם!!</button>
    </section>
    
    <div class="credits">
        יוצר באהבה רבה על-ידי <a href="https://ish.works/" target="_blank">איש.וורקס</a>.
    </div>

    <div class="privacy">
        <a href="/privacy.html" target="_blank">מדיניות פרטיות</a>
    </div>
</div>
  
  <script>

    if (navigator.userAgent && navigator.userAgent.indexOf("Macintosh") >= 0 && navigator.userAgent.indexOf("AppleWebKit") >= 0) {
        console.log("applying 1px extra tiles fix for chrome/safari on osx :|");
        // sometimes i hate open source libraries so much hahaha this is hell
        /* 
        * Workaround for 1px lines appearing in some browsers due to fractional transforms
        * and resulting anti-aliasing.
        * https://github.com/Leaflet/Leaflet/issues/3575
        */
        (function(){
            var originalInitTile = L.GridLayer.prototype._initTile
            L.GridLayer.include({
                _initTile: function (tile) {
                    originalInitTile.call(this, tile);

                    var tileSize = this.getTileSize();

                    tile.style.width = tileSize.x + 1 + 'px';
                    tile.style.height = tileSize.y + 1 + 'px';
                }
            });
        })();
    }

    (function() {
        const TLV_COLOR = `rgba(${0x63}, ${0xac}, ${0xbe}, 1)`; //'#63acbe';
        const JAFFA_COLOR = `rgba(${0xa9}, ${0x29}, ${0x9c}, 1)`; //'#a9299c';

        let GLOB_is_dark_mode = false;
        let GLOB_is_dark_forced = false; // are we forcing light/dark mode currently?

        let GLOB_is_reduced_motion = false;

        if (window.matchMedia) {
            const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
            const matchReduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

            // when we just initialize, set the dark mode flag to match browser settings
            GLOB_is_dark_mode = !!matchDarkMode.matches;
            GLOB_is_reduced_motion = !!matchReduceMotion.matches;

            matchDarkMode.addEventListener('change', event => {
                // but when the setting is changed on the fly, only update the flag
                // if the user hasn't touched the light switch
                if (GLOB_is_dark_forced) {
                    return;
                }

                GLOB_is_dark_mode = !!event.matches;
                onDarkModeSettingChanged();
            });

            matchReduceMotion.addEventListener('change', event => {
                // (no complex logic here, just set the value, cause i don't offer any way to change it in the ui)
                GLOB_is_reduced_motion = !!event.matches;
            })
        }

        function onDarkModeSettingChanged() {
            LAYER.setUrl(MAP_STYLES[GLOB_is_dark_mode|0]);
            if (STATE.question_idx <= 0) {
                refill_cache_for_mode(GLOB_is_dark_mode|0);
            }
        }

        document.getElementById('btn-light-switch').addEventListener('click', function(event) {
            // when the light switch is clicked:
            
            GLOB_is_dark_forced = true;
            GLOB_is_dark_mode = !GLOB_is_dark_mode;

            // force css to comply by adding class to the body:
            if (GLOB_is_dark_mode) {
                document.body.classList.add('force-dark');
                document.body.classList.remove('force-light');
            } else {
                document.body.classList.add('force-light');
                document.body.classList.remove('force-dark');
            }

            // and lastly, trigger the event that updates the map
            onDarkModeSettingChanged();
        });

        const STATE = window.STATE = {
            session_id: null,
            question_idx: -1,
            questions: null,
            markers: null,
            answers: null,
            answer_markers: null,

            is_animating: true,

            is_loading_results: false,
            renew_session_interval: null,
            current_session_ttl: null
        };

        const ASSETS_TO_PRELOAD = [
            // conveniently in order of appearance for typical user(tm)
            "/assets/loading.svg",
            "/assets/loading_darkmode.svg",
            "/assets/switch_light.svg",
            "/assets/switch_dark.svg",
            "/assets/marker_q.svg",
            "/assets/twemoji_catheart.svg",
            "/assets/marker_jaffa.svg",
            "/assets/marker_tlv.svg"
        ];
        const PRELOADED_IMAGE_XYZ  = window.PRELOADED_IMAGE_XYZ  = [];
        const PRELOADED_IMAGE_OBJS = window.PRELOADED_IMAGE_OBJS = [[], []];
        const TILE_SIZE = 512;
        const ZOOM_OFFSET = -1;

        const MIN_ZOOM_USUAL = 13;
        const MIN_ZOOM_ALL_ANSWERS = 12;
        const MAP_MAX_BOUNDS = L.latLngBounds(L.latLng(32.017357, 34.724041), L.latLng(32.159226, 34.867250));
        const MAP_FINAL_VIEW_BOUNDS = L.latLngBounds(
            // southwest: just outside tlv/by border
            L.latLng(32.0290,34.7512), //L.latLng(32.0290,34.7412),
            // northeast: beggin/hashmonaim
            L.latLng(32.0693,34.7877)
        )

        const MAP_STYLES = [
            'https://api.maptiler.com/maps/47c517fb-70bf-4903-89b4-2033ebbbedb1/{z}/{x}/{y}{r}.png?key=XQ643Hu2aW2ClNCu8gL4', // light
            'https://api.maptiler.com/maps/a3b10cf0-43d5-4a06-aefd-226a3a02a57c/{z}/{x}/{y}{r}.png?key=XQ643Hu2aW2ClNCu8gL4', // dark
        ];

        // initialize map and stuff
        const MAP = window.MAP = L.map('map', {
            zoomControl: false,
            bounceAtZoomLimits: false,

            minZoom: MIN_ZOOM_USUAL,
            maxZoom: 18,
            maxBounds: MAP_MAX_BOUNDS,

            maxBoundsViscosity: 1.0,
        }).setView([32.058225, 34.770073], 14);

        const LAYER = L.tileLayer(
            MAP_STYLES[GLOB_is_dark_mode | 0],{
                tileSize: TILE_SIZE,
                zoomOffset: ZOOM_OFFSET,
                attribution: "\u003ca href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"\u003e\u0026copy; MapTiler\u003c/a\u003e \u003ca href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"\u003e\u0026copy; OpenStreetMap contributors\u003c/a\u003e",
                crossOrigin: true
        }).addTo(MAP);

        const HEAT_LAYER = L.imageOverlay("", MAP_MAX_BOUNDS);

        const QUESTION_VIEW_ZOOM = 16;

        const MARKER_Q = L.divIcon({
            html: '<img src="/assets/marker_q.svg" class="pulsating">',
            className: 'no-bg-no-border',

            iconSize: [60, 75],
            iconAnchor: [15, 37.5],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_TLV = L.icon({
            iconUrl: '/assets/marker_tlv.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const MARKER_JAFFA = L.icon({
            iconUrl: '/assets/marker_jaffa.svg',

            iconSize: [22, 22],
            iconAnchor: [11, 11],
            popupAnchor: [0, 0] // ?
        });

        const CAT_HEART = L.icon({
            iconUrl: '/assets/twemoji_catheart.svg',
            
            iconSize: [36, 36],
            iconAnchor: [18, 18],
            popupAnchor: [0, 0] // ?
        });

        function playAgain() {
            // reset the state and stuff
            STATE.session_id = null;
            STATE.questions = null;
            STATE.question_idx = -1;
            STATE.answers = null;
            STATE.current_session_ttl = null;
            clear_map_images_cache();
            clear_answer_markers();

            clear_renew_session_interval();

            document.getElementById('all-answers-page').classList.add('hidden');
            document.getElementById('loading-page').classList.remove('hidden');
            resize_map();

            loadQuestionsFromServer();
        }

        function clear_renew_session_interval() {
            if (STATE.renew_session_interval !== null) {
                clearInterval(STATE.renew_session_interval);
                STATE.renew_session_interval = null;
            }
        }

        function clear_answer_markers() {
            // if (!STATE.answer_markers) {
            //     return;
            // }

            // for (let i = 0; i < STATE.answer_markers.length; i++) {
            //     STATE.answer_markers[i].remove();
            // }

            for (let i = 0; i < STATE.markers.length; i++) {
                STATE.markers[i].remove();
            }
            STATE.markers = null;

            HEAT_LAYER.remove();
            HEAT_LAYER.setUrl("");
            if (STATE.answer_markers) {
                URL.revokeObjectURL(STATE.answer_markers);
                STATE.answer_markers = null;
            }
        }

        function loadQuestionsFromServer() {
            let asset_preload_done = false;
            let question_load_done = false;
            const finishedLoading = function() {
                document.getElementById('loading-page').classList.add('hidden');
                document.getElementById('intro-page').classList.remove('hidden');
                resize_map();
            };

            preload_asset_images(ASSETS_TO_PRELOAD, function() {
                asset_preload_done = true;

                if (question_load_done) {
                    finishedLoading();
                }
            });

            fetch('/generate_session').then(function(response) {
                return response.json();
            }).then(function(o) {
                STATE.session_id = o.session_id;
                STATE.questions = o.points.map(([x, y]) => [y, x]);
                STATE.question_idx = -1; 
                STATE.answers = STATE.questions.map(() => null);
                STATE.markers = STATE.questions.map(() => null);
                STATE.current_session_ttl = o.ttl;

                const num_qs = STATE.questions.length;
                let preload_counter = 0;

                const start_ms = Date.now();

                for (const q of STATE.questions) {
                    preload_tile_neighborhood(
                        q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET, GLOB_is_dark_mode|0,
                        function() { // hello callback hell my old friend
                            preload_counter += 1; // haha gotta count till the end!!!!
                            if (preload_counter === num_qs && Date.now() - start_ms <= 1000) {
                                // load the outer zoom levels only if the inner zoom levels took less than 1s total
                                console.log('loading outer zoom levels');
                                for (const qq of STATE.questions) {
                                    preload_tile_neighborhood(q[0], q[1], QUESTION_VIEW_ZOOM + ZOOM_OFFSET - 1, GLOB_is_dark_mode|0);
                                }
                            }
                        }
                    );
                }

                clear_renew_session_interval();

                STATE.renew_session_interval = setInterval(
                    function() {
                        console.log("renewing session");
                        if (STATE.session_id && STATE.question_idx < (STATE.questions || []).length) {
                            fetch('/renew_session?session_id=' + STATE.session_id).then(function (response) {
                                return response.json();
                            }).then(function(o) {
                                STATE.current_session_ttl = o.ttl;
                            });
                        } else {
                            clear_renew_session_interval();
                        }
                    },
                    2 * 60 * 60 * 1000
                );

                question_load_done = true;
                if (asset_preload_done) {
                    finishedLoading();
                }
            }, function(err) {
                // on error haha
                console.error(err);

                document.getElementById('loading-page').classList.add('hidden');
                document.getElementById('error-page').classList.remove('hidden');
                resize_map();
            });
        }

        function showNextPoint() {
            STATE.question_idx += 1;

            if (STATE.question_idx >= STATE.questions.length) {
                showResultsLoader();
                return;
            }

            const q = STATE.questions[STATE.question_idx];
            STATE.markers[STATE.question_idx] = L.marker(q, {icon:MARKER_Q}).addTo(MAP);

            let ANIM_LEN_MS = 1500; // this variable is used for the setTimeout, even when prefers-reduced-motion is on

            if (GLOB_is_reduced_motion) {
                ANIM_LEN_MS = STATE.question_idx === 0 ? 0 : 1000;

                setTimeout(function() {
                    MAP.setView(q, QUESTION_VIEW_ZOOM, {animate: false, duration: 0});
                }, ANIM_LEN_MS);
            } else {
                if (STATE.question_idx > 0) {
                    // i checked manually, and the distance between the opposite (sw/ne) corners of tlv is about 0.1303 degrees
                    // and i want that distance to take exactly 3000 ms to traverse
                    const FLY_SPEED = 0.1303 / 3000; // deg/ms

                    const [prev_y, prev_x] = STATE.questions[STATE.question_idx - 1];
                    const [next_y, next_x] = q;

                    const dy = next_y - prev_y;
                    const dx = next_x - prev_x;

                    const distance_deg = Math.sqrt(dx*dx + dy*dy);

                    ANIM_LEN_MS = Math.max(
                        1000, // never take less than a second
                        distance_deg / FLY_SPEED // deg/(deg/ms) = deg*(ms/deg) ms*(deg/deg) = ms
                    );
                }

                MAP.stop();
                MAP.flyTo(q, QUESTION_VIEW_ZOOM, {duration: ANIM_LEN_MS / 1000.0});
            }

            setTimeout(function() {
                STATE.is_animating = false;
                BTN_TLV.removeAttribute('disabled');
                BTN_JAF.removeAttribute('disabled');
            }, ANIM_LEN_MS);
        }

        
        // let ZOOMANIM_END_TIMEOUT = null;
        
        // function recenter_question() {
        //     ZOOMANIM_END_TIMEOUT = null;
            
        //     if (!STATE.is_animating 
        //         && STATE.questions 
        //         && STATE.questions.length 
        //         && STATE.question_idx >= 0 
        //         && STATE.question_idx < STATE.questions.length)
        //     {

        //         const point = STATE.questions[STATE.question_idx];
        //         const bounds = MAP.getBounds();

        //         let needs_correction = false;

        //         if (!bounds.contains(point)) {
        //             needs_correction = true;
        //         } else {
        //             const bounds_size = Math.min(Math.abs(bounds.getEast() - bounds.getWest()), Math.abs(bounds.getNorth() - bounds.getSouth()));

        //             const center = MAP.getCenter();
        //             const dx = center.lng - point[1];
        //             const dy = center.lat - point[0];

        //             const dist = Math.sqrt(dx*dx + dy*dy);

        //             if (dist > bounds_size * 0.3333) {
        //                 needs_correction = true;
        //             }
        //         }

        //         if (needs_correction) {
        //             MAP.flyTo(point, Math.max(13, MAP.getZoom()), {duration: 1.0});
        //         }
        //     }
        // }

        // MAP.on("zoomanim", function() {
        //     if (ZOOMANIM_END_TIMEOUT !== null) {
        //         clearTimeout(ZOOMANIM_END_TIMEOUT);
        //     }

        //     if (!STATE.is_animating 
        //         && STATE.questions 
        //         && STATE.questions.length 
        //         && STATE.question_idx >= 0 
        //         && STATE.question_idx < STATE.questions.length)
        //     {
        //         ZOOMANIM_END_TIMEOUT = setTimeout(recenter_question, 800);
        //     }
        // });

        function addAnswer(isJaffa) {
            if (STATE.is_animating) {
                console.warn("can't answer while still animating to next answer");
                return;
            }

            if (STATE.question_idx < 0 || STATE.question_idx > STATE.questions.length) {
                console.error("tried to add answer when no answers pending");
                return;
            }

            if (reload_if_session_expired()) { return; } // this is here mainly as a backup, in case document.onvisibilitychange didn't fire

            const marker = STATE.markers[STATE.question_idx];
            marker.setIcon(isJaffa ? MARKER_JAFFA : MARKER_TLV);

            // add a nice rewarding fading face
            const reward = L.marker(STATE.questions[STATE.question_idx], {icon:CAT_HEART}).addTo(MAP);
            reward.getElement().classList.add("fading-reward");

            STATE.answers[STATE.question_idx] = isJaffa;
            STATE.is_animating = true;
            BTN_JAF.setAttribute('disabled', 'disabled');
            BTN_TLV.setAttribute('disabled', 'disabled');

            setTimeout(() => {
                reward.remove();
            }, 1000);

            setTimeout(() => {
                // document.getElementById(isJaffa ? "btn-jaf" : "btn-tlv").blur(); // ha ha this doesn't work
                showNextPoint();
            }, 600);
        }

        function showResultsLoader() {
            clear_renew_session_interval();
            STATE.current_session_ttl = null;

            document.getElementById('question-page').classList.add('hidden');
            document.getElementById('results-loading-page').classList.remove('hidden');
            resize_map();

            clear_map_images_cache();

            MAP.setMinZoom(MIN_ZOOM_ALL_ANSWERS);
            MAP.setMaxBounds(MAP_MAX_BOUNDS);
            if (GLOB_is_reduced_motion) {
                setTimeout(function() {
                    MAP.fitBounds(MAP_FINAL_VIEW_BOUNDS, {animate: false, duration: 0});
                }, 1000);
            } else {
                MAP.stop();
                MAP.flyToBounds(MAP_FINAL_VIEW_BOUNDS);
            }

            const answers = STATE.answers.map((x) => x|0).join(',');
            
            // actually send to a server lol
            fetch(`/answer_session?session_id=${STATE.session_id}&answers=${answers}&get_all_answers=1`).then(function(response) {
                return response.json();
            }).then(function(o) {
                return generate_heatmap(
                    o, 100, 0.7, 1, 14
                );
            }).then(function(heatmap) {
                heatmap.toBlob(function(blob) {
                    STATE.answer_markers = URL.createObjectURL(blob);
                    HEAT_LAYER.setUrl(STATE.answer_markers);
                    HEAT_LAYER.setOpacity(0.7);
                    HEAT_LAYER.addTo(MAP);

                    // TODO: maybe add a timeout? or somehow hook into HEAT_LAYER.getElement().onload?
                    document.getElementById('results-loading-page').classList.add('hidden');
                    document.getElementById('all-answers-page').classList.remove('hidden');
                    resize_map();

                    MAP.dragging.enable();
                    MAP.options.touchZoom = true;
                    MAP.options.scrollWheelZoom = true;
                });

                // const tlv_point = 32.063602;
                // const jaf_point = 32.040754;
                // STATE.answer_markers = [];
                // STATE.answers = test__generateRandomPointsInPolygon(
                //     2000,
                //     TLVORJ_POLYGON_LOL.features[0].geometry.coordinates[0]
                // ).map(
                //     function([x, y]) {
                //         const tlv_chance = 
                //             (y > tlv_point) ? 1 : (
                //                 (y < jaf_point) ? 0 : (
                //                     (y - jaf_point) / (tlv_point - jaf_point)
                //                 )
                //             );
                //         const is_jaffa = (Math.random() >= tlv_chance);
                //         const coord = [y, x];
                //         // someday future me is going to look at this function and think "how dumb was i back then?"
                //         // that day could very well be tomorrow morning
                //         STATE.answer_markers.push(
                //             L.marker(coord, {icon:is_jaffa ? MARKER_JAFFA : MARKER_TLV}).addTo(MAP)
                //         );
                //         return {coord, is_jaffa};
                //     }
                // );
            }, function(err) {
                // on error haha
                console.error(err);

                document.getElementById('results-loading-page').classList.add('hidden');
                document.getElementById('error-page').classList.remove('hidden');
                resize_map();
            });
        }

        const BTN_TLV = document.getElementById('btn-tlv');
        const BTN_JAF = document.getElementById('btn-jaf');

        BTN_TLV.addEventListener('click', event => { addAnswer(false); });
        BTN_JAF.addEventListener('click', event => { addAnswer(true);  });
        document.getElementById('btn-start').addEventListener('click', event => {
            if (reload_if_session_expired()) { return; } // this is here mainly as a backup, in case document.onvisibilitychange didn't fire

            document.getElementById('intro-page').classList.add('hidden');
            document.getElementById('question-page').classList.remove('hidden');
            MAP.dragging.disable();
            MAP.setMaxBounds(null); // no point in having max bounds when the user can only zoom (and it sometimes bugs as a bonus)
            MAP.options.touchZoom = 'center';
            MAP.options.scrollWheelZoom = 'center';
            resize_map();
            showNextPoint();
        });
        document.getElementById('btn-playagain').addEventListener('click', event => {
            playAgain();
        });
        setTimeout(() => loadQuestionsFromServer(), 0);
        document.getElementById('btn-retry').addEventListener('click', event => {
            window.localStorage.clear();
            window.location.reload();
        });


        function get_tile_src(url_template, {x, y, z}) {
            return url_template
                .replace("{z}", ""+Math.floor(z))
                .replace("{x}", ""+Math.floor(x))
                .replace("{y}", ""+Math.floor(y))
                // did you know? i really hope this is legally distinct from how the incomaptibly-licensed Leaflet source code does this check!
                .replace("{r}", (L.Browser.retina && "@2x") || "");
        }

        function preload_image_impl(src, onload, onerror) {
            const link = document.createElement('link');
            if (onload) {
                link.addEventListener('load', onload);
            }
            if (onerror) {
                link.addEventListener('error', onerror);
            }
            // link.classList.add('preloaded');
            // img.width = 1;
            // img.height = 1;
            link.href = src;
            link.as = "image";
            link.rel = "preload";
            document.head.appendChild(link);

            return link;
        }

        function preload_map_image(xyz, mode_idx, onload) {
            PRELOADED_IMAGE_XYZ.push(xyz);

            PRELOADED_IMAGE_OBJS[mode_idx].push(preload_image_impl(get_tile_src(MAP_STYLES[mode_idx], xyz), onload));
        }

        const MAX_ASSET_PRELOAD_MS = 1500;

        function preload_asset_images(all_urls, on_all_done) {
            let loaded_or_erred = 0;
            const total_imgs = all_urls.length;
            let done = false;
            const images = [];

            const inc_counter = function() {
                loaded_or_erred += 1;
                if (loaded_or_erred >= total_imgs && !done) {
                    done = true;
                    on_all_done(images);
                }
            }

            // i don't want random asset preloading fails to make the initial loading hang forever
            // (did you know? the internet is shit)
            // so there's a 1.5-second maximum time that i allow the asset preloading to take
            setTimeout(function() {
                if (!done) {
                    done = true;
                    console.warn("asset loading timeout reached");
                    on_all_done(images);
                }
            }, MAX_ASSET_PRELOAD_MS);

            for (const url of all_urls) {
                images.push(preload_image_impl(
                    url,
                    inc_counter,
                    function(error_data_hopefully) {
                        console.error('error loading asset', error_data_hopefully);
                        inc_counter();
                    }
                ));
            }
        }

        function clear_map_images_cache() {
            PRELOADED_IMAGE_XYZ.splice(0, PRELOADED_IMAGE_XYZ.length);
            for (let mode_idx = 0; mode_idx < MAP_STYLES.length; mode_idx++) {
                PRELOADED_IMAGE_OBJS[mode_idx].splice(0, PRELOADED_IMAGE_OBJS[mode_idx].length);
            }
        }

        function refill_cache_for_mode(mode_idx) {
            const objs = PRELOADED_IMAGE_OBJS[mode_idx];

            if (objs.length < PRELOADED_IMAGE_XYZ.length) {
                for (let i = objs.length; i < PRELOADED_IMAGE_XYZ.length; i++) {
                    objs.push(
                        preload_image_impl(get_tile_src(
                            MAP_STYLES[mode_idx],
                            PRELOADED_IMAGE_XYZ[i]
                        ))
                    );
                }
            }
        }

        function long2tileFrac(lon,zoom) {
            return (lon+180)/360 * Math.pow(2,zoom);
        }
        function lat2tileFrac(lat,zoom) {
            return (
                1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI
            )/2 * Math.pow(2,zoom);
        }
        

        function get_viewport_size() {
            return [
                Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
                Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
            ];
        }

        function tile_neighborhood_for_coord(lat, long, zoom, hell_callback) {
            const center_xy = [long2tileFrac(long, zoom), lat2tileFrac(lat, zoom)];

            const [vw, vh] = get_viewport_size();
            const half_vcols = vw / TILE_SIZE / 2;
            const half_vrows = vh / TILE_SIZE / 2;

            const left = Math.floor(center_xy[0] - half_vcols);
            const top = Math.floor(center_xy[1] - half_vrows);
            const right = Math.floor(center_xy[0] + half_vcols);
            const bottom = Math.floor(center_xy[1] + half_vrows);

            const total_imgs = (right - left + 1) * (bottom - top + 1);

            for (let x = left; x <= right; x++) {
                for (let y = top; y <= bottom; y++) {
                    hell_callback({x, y, z: zoom}, total_imgs);
                }
            }
        }

        function preload_tile_neighborhood(lat, long, zoom, mode_idx, on_all_done) {
            let loaded_counter = 0;

            const coords = tile_neighborhood_for_coord(lat, long, zoom, function(xyz, total_imgs) {
                // it's called "hell_callback" because we are now officially in callback hell! {confetti emoji}
                preload_map_image(xyz, mode_idx, function(event) {
                    loaded_counter += 1;
                    console.log(`loaded image ${loaded_counter}/${total_imgs}`, event.target);

                    if (loaded_counter === total_imgs && on_all_done) {
                        on_all_done();
                    }
                });
            });
        }

        const HEATMAP_CANVAS = document.createElement("canvas");

        function generate_heatmap(
            all_answers_xyj, point_radius, blur_factor, max_opacity, zoom_level
        ) {
            // i tried using some weird 5-year-old leaflet plugin but it was crap
            // so i'll just make my own????

            const bounds_nw = MAP_MAX_BOUNDS.getNorthWest();
            const bounds_se = MAP_MAX_BOUNDS.getSouthEast();

            // TODO: retina???? :|:|:|

            const [[minx, miny], [maxx, maxy]] = [
                [
                    Math.floor(TILE_SIZE * long2tileFrac(bounds_nw.lng, zoom_level)),
                    Math.floor(TILE_SIZE * lat2tileFrac(bounds_nw.lat, zoom_level))
                ],
                [
                    Math.round(TILE_SIZE * long2tileFrac(bounds_se.lng, zoom_level)),
                    Math.round(TILE_SIZE * lat2tileFrac(bounds_se.lat, zoom_level))
                ]
            ];

            HEATMAP_CANVAS.width = maxx - minx;
            HEATMAP_CANVAS.height = maxy - miny;
            HEATMAP_CANVAS.style.background = "transparent";

            const ctx = HEATMAP_CANVAS.getContext("2d");
            ctx.clearRect(0, 0, HEATMAP_CANVAS.width, HEATMAP_CANVAS.height);

            ctx.strokeStyle = "none";

            const opacity = "" + Math.max(0, Math.min(1, max_opacity));
            
            const tlv_color_trans =   TLV_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + opacity + ")"));
            const jaf_color_trans = JAFFA_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + opacity + ")"));

            const tlv_color_trans0 =   TLV_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + "0)"));
            const jaf_color_trans0 = JAFFA_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + "0)"));

            const generateOneBlob = ([lng, lat, is_jaffa]) => {
                const x = Math.round(TILE_SIZE * long2tileFrac(lng, zoom_level) - minx);
                const y = Math.round(TILE_SIZE * lat2tileFrac(lat, zoom_level) - miny);

                const gradient = ctx.createRadialGradient(
                    x, y, point_radius * Math.max(0, Math.min(1, 1-blur_factor)),
                    x, y, point_radius
                );

                gradient.addColorStop(0, is_jaffa ? jaf_color_trans : tlv_color_trans);
                gradient.addColorStop(1, is_jaffa ? jaf_color_trans0 : tlv_color_trans0);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(x, y, point_radius, point_radius, 0, 0, 2 * Math.PI);
                ctx.fill();
            };

            // this used to just all be generated in one go, but when the
            // number of answers in the db gets to several hundreds (oh, those
            // were the days!!!), this makes some devices freeze because this
            // hogs the entire singular js thread;

            // so instead, this is now done in small chunks, via setTimeout,
            // and the function returns a promise that's resolved after
            // everything's done
            return new Promise((resolve) => {
                let i = 0;
                const chunkSize = 10;

                const generateMoreBlobs = () => {
                    for (let j = 0; j < chunkSize && i < all_answers_xyj.length; j++, i++) {
                        generateOneBlob(all_answers_xyj[i]);
                    }

                    if (i < all_answers_xyj.length) {
                        setTimeout(generateMoreBlobs, 10);
                    } else {
                        resolve(HEATMAP_CANVAS);
                    }
                };

                setTimeout(generateMoreBlobs, 10);
            });
        }

        function init_heatmap_legend(point_radius, blur_factor, max_opacity) {
            const CANVAS_TLV = document.getElementById('legend-other-tlv');
            const CANVAS_JAF = document.getElementById('legend-other-jaf');

            const CTX_TLV = CANVAS_TLV.getContext('2d');
            const CTX_JAF = CANVAS_JAF.getContext('2d');

            CTX_TLV.strokeStyle = "none";
            CTX_JAF.strokeStyle = "none";

            const opacity = "" + Math.max(0, Math.min(1, max_opacity));
            
            const tlv_color_trans =   TLV_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + opacity + ")"));
            const jaf_color_trans = JAFFA_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + opacity + ")"));

            const tlv_color_trans0 =   TLV_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + "0)"));
            const jaf_color_trans0 = JAFFA_COLOR.replace(/([,]\s*)1[)]/, (m, p) => (p + "0)"));

            for (let is_jaffa = 0; is_jaffa < 2; is_jaffa++) { // haha ;)
                const canvas = is_jaffa ? CANVAS_JAF : CANVAS_TLV;
                const ctx    = is_jaffa ? CTX_JAF    : CTX_TLV;
                
                const x = Math.round(canvas.width / 2);
                const y = Math.round(canvas.height / 2);

                const gradient = ctx.createRadialGradient(
                    x, y, point_radius * Math.max(0, Math.min(1, 1-blur_factor)),
                    x, y, point_radius
                );

                gradient.addColorStop(0, is_jaffa ? jaf_color_trans : tlv_color_trans);
                gradient.addColorStop(1, is_jaffa ? jaf_color_trans0 : tlv_color_trans0);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(x, y, point_radius, point_radius, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        init_heatmap_legend(10, 0.7, 1);

        window.addEventListener("resize", function() {
            resize_map();
        });

        function recenter_question(resize_amount) {
            if (!STATE.is_animating && STATE.questions && STATE.questions.length 
                && 0 <= STATE.question_idx && STATE.question_idx < STATE.questions.length)
            {
                MAP.setView(STATE.questions[STATE.question_idx], MAP.getZoom(), {animate: false, duration: 0});
            }
        }

        function resize_map() {
            setTimeout(function() {
                const ui = document.getElementById("main-ui");
                const map = document.getElementById("map");

                if ((ui.offsetTop + ui.offsetHeight) / window.innerHeight > 0.99) { // lol
                    map.style.bottom = ui.offsetHeight + "px";
                } else if (parseInt(map.style.bottom) !== 0) {
                    map.style.bottom = "0px";
                }
                
                MAP.invalidateSize(true);

                setTimeout(recenter_question, 0); // haha nesting these isn't cursed at all hahahahahahahslhsasldfjoweijfz;lkjfasdl;kfjasd;ofwije
            }, 0);
        }


        const LAST_FORCE_RELOAD = "LAST_FORCE_RELOAD";

        document.addEventListener("visibilitychange", function() {
            if (document.visibilityState === "visible") {
                reload_if_session_expired();
            }
        });
        
        function reload_if_session_expired() {
            if (STATE.current_session_ttl
                && STATE.current_session_ttl - Math.floor(Date.now() / 1000) < 3600)
            {
                // if there's less than an hour remaining for the session to expire (or if it's already expired)
                console.warn("session expired or very close to; reloading")

                const lastForceReload = parseInt(window.localStorage.getItem(LAST_FORCE_RELOAD));
                
                if (!isNaN(lastForceReload) && lastForceReload && Date.now() - lastForceReload < 10 * 60 * 1000) {
                    console.warn("recently reloaded! skipping this reload for fear of a reload loop bug"); // am i imagining bugs that'll never happen? idk
                } else {
                    window.localStorage.setItem(LAST_FORCE_RELOAD, "" + Math.floor(Date.now()));
                    window.location.reload();

                    return true;
                }
            }

            return false;
        }
        
    })();
  </script>
</body>
</html>